00:03
1장 씨불불의 시작 시작하도록 하겠습니다. 이런 순서대로 설명을 할 거고요.
목차는 진행하면서 얘기하도록 하겠습니다. 일단 이번 페이지 타이틀이 세상을 먹어치우는 소프트웨어 좀 공격적인데요.
최근 소프트웨어 기업의 세상입니다. 여러 기업들이 있지만 특히 소프트웨어 특히 AI 관련 기업들 요새 많이 뜨고 있죠.
구글 애플, 삼성, 아마존 페이스북, 마이크로소프트 다 보면은 소프트웨어 쪽에서 좀 이름이 좀 있는 회사들이죠.
이런 회사들이 뉴스에도 많이 나오고 최근에 여러 기술들을 선보이고 있죠.
그래서 지금 일어나고 있는 이런 4차 산업의 핵심에 소프트웨어가 있다 이런 얘기들 많이 하죠.
뉴스도 많이 나왔고요. 그래서 무인 자동차 AI CHPT 알파고 IBM 왓슨 IoT 이런 데서도 계속 다 소프트웨어의 중요성을 강조하고 있습니다.
근데 이렇게만 넘어가면 여러분들이 이제는 소프트웨어가 되게 중요하구나 이렇게 인식하고 또 반대로는 이제 하드웨어의 중요성이 좀 낮아졌나 이런 식으로 또

01:21
생각이 들기도 하잖아요. 근데 여러분들 이 회사 여러 회사들 중에서도 애플 대표적인 소프트웨어 회사죠.
그렇지만 애플의 강점 중 하나는 또 하드웨어입니다.
칩 같은 거 에몬 칩, m2 칩 이런 칩을 잘 만드는 거 이런 것도 강점이고 삼성 같은 경우 메모리 마이크로소프트는 여기 좀 하드웨어가 없긴 하네.
그래도 얘도 노트북 같은 거 레타 만들고 하잖아요.
이런 식으로 하드웨어가 받쳐줘야 소프트웨어 성능이 제대로 나옵니다.
근데 과거에는요. 그냥 어떻게 했나 소프트웨어가 확실히 덜 중요하게 생각했던 것 같아요.
그러니까 어떤 하드웨어를 사면 소프트웨어는 그냥 공짜로 같이 주는 이 정도 느낌이었기 때문에 그냥 소프트웨어 가격을 아예 안 쳐줬습니다.
하드웨어 가격만 있었거든요. 근데 이제는 그렇지 않습니다.
이제 소프트웨어 자체도 이게 되게 중요하고 이 자체에도 많은 기술이 있구나를 이제 서로 인식하고 있고 가격을 매겨주죠.

02:27
그래서 예전보다 소프트웨어 중요성이 올라갔다는 거지 하드웨어는 요새 안 중요하고 소프트웨어만 중요해 이건 아닙니다.
그래서 하드웨어와 소프트웨어가 서로 잘 서로 상호 보완을 해야지 제품이라든가 아니면 서비스 이런 데서 제대로 성능을 낼 수가 있는 거죠.
예를 들어서 요새 뭐랄까요? m비디아 같은 경우 있죠.
mbd아 같은 경우는 하드웨어 회사잖아요. mbd아 요새 엄청납니다.
그렇지만 mbda가 제공하는 하드웨어가 있어야지 소프트웨어 기업들이 자신의 제품들을 잘 만들 수 있죠.
그런 식으로 이제 상호 보완하는 시대가 된 것 같습니다.
그래서 소프트웨어를 만들려면 프로그램을 짜야죠.
이 프로그래밍을 해야죠. 그런 프로그래밍을 할 때 사용되는 툴 그런 것을 우리 프로그래밍 언어죠.
어떤 언어를 가지고서 소프트웨어를 만들면 이 소프트웨어를 가지고서 이제 CPU나 mpu 이런 게 동작을 하면서 내가 만들어놓은 어떤 특정한 동작을 내가 의도한 특정한 동작을 하게 되죠.

03:38
그럼 프로그래밍 언어에 대해서 얘기를 할 건데요.
이게 프로그래밍 언어의 수준에 따라서 기계어 또 어셈블리어 또는 고급 언어 이렇게 나눌 수가 있습니다.
이게 또 교재마다 조금 다르긴 한데 이게 대표적입니다.
기계와 어셈블리와 고급 언어로 나누는 게 첫 번째 가장 저수준의 프로그래밍 언어를 보면 그게 기계어고요.
0과 1의 이진수로 구성된 언어이고요. 컴퓨터의 CPU는 본질적으로 기계어만 처리 가능합니다.
그러니까 결국 컴퓨터가 있는 프로그래밍 언어는 리드 라이트 이런 게 아니라 그냥 01 11 1011 00 이렇게 쭉 적혀 있는 이런 이진수의 나열 요거를 읽어다가 프로그램을 실행하는 거죠.
왜냐하면 CPU는 뭐 다 하드웨어니까 영 이진수로 되어 있는 하드웨어니까 자기가 읽고 쓰는 데이터 자체도 다 이진수가 됩니다.
그래서 이렇게 표현되어 있는 프로그래밍 언어를 우리는 기계어라고 합니다.
그런데 이 기계어 자체를 우리가 만들 수 있으면 좋은데

04:52
여러분들이 이거 이렇게 쓰라고 하면 여러분 못 쓰잖아요.
그렇죠 뭐 외워서 한두 개 정도는 쓸 수 있겠지 하지만 이런 걸 이런 패턴 자체를 외워서 프로그래밍하는 건 불가능하죠.
그렇기 때문에 초창기에 만든 프로그래밍 언어가 어셈블리어입니다.
그래서 기계의 명령을 애드 서브 무브 같이 아주 단순한 명령어로 이제 명령어들을 집합으로 만드는 거야 이런 등과 같은 상징적인 니모니큐 로 일대응 대응시킨 언어입니다.
실제로 CPU가 처리하는 이런 에드 서브 무브 이런 명령 인스트럭션이 있거든요.
이거를 진짜로 그냥 프로그래밍 언어로서 사용을 하는 거죠.
그래서 어셈블리어는 어셈블리어는 실제 기계에서 쓰이는 그런 인스트럭션 명령어들과 1대1 정말로 매핑을 합니다.
거의 그래서 이 어셈블러라고 하는 것은요. 어셈블리어 프로그램을 기계어 코드로 변환하는 그거를 변환하는 것을 우리는 어셈블러라고 합니다.
얘가 해주는 거예요. 어셈블러가 어셈블리어를 기계어로 변환해줍니다.

06:03
근데 어셈블리어 자체도 너무 CPU에서 사용하는 1차적인 명령어의 집합입니다.
그렇기 때문에 사람이 읽을 때 아직은 읽을 수 있어 요 정도만 되면 읽을 수 있어 공부하면 예전에는 제가 알기로 게임을 그냥 어셈블리어로 만들어서 뭐 좀 이슈가 되고 이랬던 적이 있었죠.
좀 무슨 게임이었는지 내가 이름은 기억이 안 나네.
근데 아주 좀 복잡한 게임 자체도 그냥 어셈블리어로 만들었던 만들어서 이게 기사가 나고 이랬던 적이 있었습니다.
다음 그래서 우리가 사람 읽기에 좀 더 편안한 언어 그래서 고급 언어라고 하는데 사람이 이해하기 쉽고 복잡한 작업 자료구조 알고리즘을 표현하기 위해 고안된 언어입니다.
그래서 여러 포문 ef문 스위치문 함수 뭐 이런 여러 가지 우리가 사용하는 그런 규칙들 있잖아요.
그런 것들을 포함하고 있는 프로그래밍 언어 그걸 우리 고급 언어라고 하고요.
대표적으로 바스칼 베이직 CC불불 자바 c샵, 파이썬 자바스크립트 이런 언어들

07:13
실제로 우리가 사용하는 건 다 고급 언어입니다. 고급 언어 이런 것들이 있고요.
고급 언어 중에서도 컴파일러를 사용하는 고급 언어가 있고요.
인터프리터를 사용하는 고급 언어가 있습니다. 컴파일러를 사용하는 것은요.
작성된 프로그램을 기계화 코드로 변환 이게 덩어리로 전체를 한 번에 변환 요 말입니다.
그래서 여러분이 코드를 아주 길게 자 그러면 이제 실행하기 전에 여러분이 짠 그 긴 코드를 긴 코드를 기계어 코드로 한꺼번에 일단 변환을 하고 그다음에 기계어 코드를 변환된 기계 코드를 계속 읽어가면서 실행하는 게 이 컴파일러 베이스의 컴파일러의

08:02
그

08:03
베이스로 한 고급 언어고요. 또 인터프리터 기반으로 한 것도 있죠.
컴파일러하고 유사하나 얘는 한꺼번에 다 변환하는 게 아니라 그냥 한 줄씩 한 줄씩 기계화로 변환을 하면서 실행을 합니다.
이거 각자 장단이 있겠죠 컴파일러 같은 경우에는 전체를 한꺼번에 변환하기 때문에 일단은 실행하기 전에 할 일이 많아 전체를 한번 쫙 코드를 다 보고 변환이 되는지 안 되는지 그리고 오류가 구석구석에 있는 거 다 얘기합니다.
여기 오류 있어 빨리 잡아 이렇게 얘기하는 게 컴파일러고요.
인터프리터는 내가 사용할 그 부분만 한 줄씩 넘어가거든요.
그렇기 때문에 오류가 있더라도 설령 내가 사용하지 호출되지 않는 부분에 있는 오류는 그냥 넘어갈 때가 넘어가서 실행할 수가 있습니다.
이런 거 이거는 장점이자 단점입니다. 그래서 실행 자체는 실행은 컴파일러가 빠릅니다.
그렇지만 그 변환하는 속도는 더 오래 걸리겠죠. 인터프리터는 변환하는 건 금방금방 변환하지만 실행할 때마다 실행할 때마다

09:09
한 줄씩 한 줄씩 기계화로 변환을 해야 되기 때문에 상대적으로 실행하는 속도는 느립니다.
변환하는 속도는 빠르지만 한 줄이기 때문에 실행하는 속도는 느리다 이런 장단이 있습니다.
앞에서 얘기했던 그 내용을 그림으로 표현을 해봤는데요.
이게 c 또는 씨불불 고급 언어죠. 이렇게 이제 작성된 코드가 있으면요.
이 코드를 이 코드를 컴파일을 하면 이 sf 코드가 어셈블리어로 변환이 됩니다.
그런 다음에 이 변환된 코드를 다시 어셈블 하면은 이게 기계어로 변환이 돼 그래서 이 기계어가 이 CPU가 이 CPU입니다.
CPU CPU가 CPU가 이거 한 줄씩 한 줄씩 계속 읽어가죠.
읽어가고 읽어가고 읽어가고 이렇게 하면서 이제 프로그램을 실행을 하는 거죠.
근데 여기서 얘기하는 게 여기서 보니까 컴파일을 하니까 고급 언어에서 어셈블리어가 나오네.
근데 앞장에서는 컴파일 하면 기계가 나온다고 했잖아요.
이게

10:12
책마다 조금 달라 어떤 책은 컴파일 하면 기계가 나온다고 하고 어떤 책은 컴파일 하면 어셈블리어가 나온다고 하고 여기저기 좀 섞여 있습니다.
이게 왜냐하면 예전에는 이게 확실히 컴파일 하면 어셈블리어 나오고 어셈블 하면 기계어 나오고 이렇게 과거에는 이렇게 딱 떨어졌거든요.
근데 최근에는 컴파일을 사실 하면은 어셈블리어도 나오고 기계도 나오고 같이 나옵니다.
그래서 컴파일이라는 게 좁은 의미에서는 여기 어셈블리어로 변환해주는 게 작은 의미의 컴파일이고요.
큰 의미로 하면 그냥 컴파일 하면은 그냥 고급 언어에서 기계 언어로 변환해주는 중간에 어셈블리어가 나오기도 하겠죠.
이런 거 좀 넓은 의미의 컴파일 요게 혼용되고 있습니다.
이게 그러니까 누가 맞고 누가 틀리다가 아니라요.
최근에는 뭐 예를 들어서 이런 비주얼 스튜디오 같은 것도 컴파일 하면은 그냥 어셈블리 나오고 기계어도 같이 나오죠.
그래서 이렇게 좀 변화하고 있다. 넓은 의미로 이렇게 받아들여주면 될 것 같습니다.

11:19
이제 프로그래밍 언어가 나온 지도 오래 됐죠. 그래서 이게 갑자기 뚝 떨어진 게 아니라 프로그래밍 언어도 이렇게 히스토리가 있습니다.
처음에 어셈블리가 있었고요. 그다음에 오른쪽으로 포트란 알골 뭐 이렇게 나왔는데 이게 제가 알기로 하나가 포트란이 미국 쪽이고 알고리 유럽 쪽일 거예요.
그리고 서로 좀 다른 언어를 갖고 경쟁을 했고 포털을 기반으로 해서 베이직이 나오고 그다음에 이거 베이직에다가 좀 ui 같은 기능 좀 더 넣은 비주얼 베이직이 나왔습니다.
그래서 알골에서 오브젝트 c 나오고 자바스크립트 나오고 그다음에 비주얼 베이직 요 이게 이제 ui가 많이 조가 된 거죠.
그래서 이런 거 강조가 된 최근에는 c샵 이거 ms에서 마이크로소프트에서 밀고 있는 시샵이 나왔고 이렇게 해서 나온 요 코스가 있고 왼쪽으로는 이제 c 계열로 보면요.
CPL 진짜 초기 모델이고요. 그다음에 이걸 갖고 b가 나왔고 그다음에 72년도에 c가 나왔습니다.
그래서 여기서 이제 우리가

12:28
기반으로 해서 이때 이게 잘 만들었다 소리가 돼서 펄리나 씨불불 오브젝트c 이런 데서 이제 사용을 했죠.
그래서 자바스크립트 만들 때도 여기 있는 문법을 많이 갖고 갔고요.
그래서 c 기반으로 해서 이게 없어진 게 아니라 아직까지 많이 사용되고 있고 그다음에 요 c 기반으로 한 이 씨뿔뿔이 여기 1979년에 79년에서 83년도 사이에 개발을 했습니다.
그래서 처음으로 요거 표준화가 된 게 98년도 거예요.
이거 98년도에 1부 표준화가 됐고 표준화를 계속 진행하면서 98 03 11 14 17 20 이런 식으로 계속 업데이트 되어 나아가고 있습니다.
어떤 것들은 이제 사장 된 것도 있고 저는 베이직 이거 비주얼 베이직 요거까지 한번 해본 것 같네요.
아주 어렸을 때 이것까지 해봤고 자바스크립트는 지금도 가끔 보죠.
이 웹 쪽 하는 사람들은 계속 보고요. 그리고 PHP 요새 약간 내려간 것 같은데 이거 서버 하는 데서 많이 쓰고 있고

13:31
시샵이야 계속 쓰고 있고 해서 이제 사라진 것도 있고 남아있는 언어도 있습니다.
근데 우리는 이쪽으로 집중해서 보도록 하겠습니다.
1불뿔 언어 이게 처음에는 표준 없이 여러 단체에서 기술 문서 같은 게 있었죠.
기술문서 기반으로 개발이 됐는데 그러다 보니까 약간 만드는 사람마다 좀 달랐어요.
회사마다 좀 달랐어. 그렇기 때문에 1998년도 미국 표준원에서 ansi에서 표준을 작성을 했고요.
1부에 대한 표준을 설정을 했고 isoiec 1488이 이 문서에서 이 표준을 기술을 했습니다.
근데 처음에는 제가 알기로 이게 무료가 아니었던 걸로 알고 있어요.
그래서 돈을 내서 다운받아야 되고 이랬던 것 같습니다.
근데 다음에 이제 98년도 만들고 03년도 만들고 2007년도 만들고 2011년도 만들고 이렇게 해서 그냥

14:29
표준을 계속 진화하고 있죠. 뭐 새로운 표준을 만든다는 게 아니라 기존 표준에다 새로운 문법 더하고 아니면 기능 같은 거 수정하고 이런 거 해서 계속 업데이트해 나가고 있습니다.
지금 나온 게 지금 나온 게 20까지 나와서 사용하고 있고요.
지금 2 3 버전 만들어서 개발 중이고 나중에 나오겠죠 이렇게 나올 것 같습니다.
그리고 표준이 왜 중요하냐 왜냐하면은

15:00
표준을

15:01
서로 다 지키면은 표준을 지키면서 짠 코드는 어떤 프레임웍에서 동작시키더라도 동일한 동작을 하게 되겠죠.
그렇기 때문에 표준이 중요합니다. 그래서 여러분들이 표준을 따르기만 한다면은 표준을 다 구현해 놓은 여러 컴파일러라든지 시스템이라든지 그런 데서 다 동작을 정상 동작을 할 거기 때문에 그래서 표준에 의해 작성된 시플 프로그램은요 모든 플랫폼 모든 표준 시플 컴파일러에 의해서 컴파일이 가능해야 하고요.
그리고 컴파일되고 실행 결과가 똑같아야 됩니다.
이게 미묘한 게 예를 들어서 여러분들 이렇게 해볼까요? a는 b c 뭐 이런 구분이 있다고 해볼까요? 근데 이거를 이제 표준을 안 정해놓으면 이거는 이제 뭐랄까 구현해 놓은 컴파일러를 구현하는 사람 마음입니다.
표준이 없다면은 예를 들어서 이거 b를 a에다 넣고 그다음에 c를 b에다 넣는다 뭐 이렇게 구현할 수도 있고 누구는 c를 b에다 넣고 그다음에 b를 a에 다 넣는다

16:02
이렇게 되면 값이 다르겠죠. 요 a 값을 보면은 위쪽으로 가면은 a는 결국 b가 되겠고 아래쪽으로 가면은 a는 결국 c가 되겠죠.
그럼 이런 거 표준을 안 정해놓으면은 구현에 요 10불불을 지원하는 회사마다 이거를 자기 마음대로 마음대로라기보다는 자기한테 맞게 이렇게 컴파일링하는 과정을 거칠 것입니다.
따라서 이런 거 다 표준을 해야겠죠. 그래서 이거 정해놓은 게 이겁니다.
이 아래쪽으로 합니다. 참고로 그래서 c를 b에 넣고 b를 a에다 넣는 이런 식으로 되어 있습니다.
그래서 이거 정해져 있어요. 지켜야 됩니다. 그래서 동일한 실행 결과를 보장하기 위해서는 표준이 중요하고요.
그리고 운영 체제와 컴파일러의 종류에 관계없는 높은 호환성을 갖습니다.
그죠? 일단 짜놓으면은 모든 시플 컴파일러에서 동일한 동작을 하기 때문에 호환성이 높다고 할 수 있습니다.
그런데 안타깝게도 아직도 비표준 1불 프로그램들이 있습니다.

16:59
예를 들어서 비주얼 시불뿔, 볼랜드 시불 등 컴파일러 회사 고유의 비표준 구문이 있어 또 이게 비표준이라는 게 여러분들 새로운 문법을 넣는 것도 있지만 어떤 거는 지원하면 안 되는데 지원하는 것도 있습니다.
표준에서 어긋나는 거야 그러면은 컴파일링 할 때 컴파일에로 내고 딱 끝내야 되는데 그냥 컴파일러가 이거는 그냥 이런 의도로 했겠거니 하고 표준은 아니지만 지원을 해버립니다.
그렇게 되면은 그런 컴파일러에 의해서 작성 컴파일러를 이용해서 작성된 소스 코드는 다른 회사의 컴파일러로 가면 동작 안 할 수가 있겠죠.
그래서 이런 식으로 비표준 10불 프로그램이 아직도 좀 남아있습니다.
그래서 이런 경우에는 특정 c불불 컴파일러에서만 컴파일이 가능하고 이렇게 되니까 아까 반대겠죠.
높은 호환성의 반대인 호환성이 결여가 됩니다.

17:56
요 구분을 볼까요? 이게 실제로 시불불 프로그램이고 짧은 프로그램이고 여기에 보면 표준이에요.
다 표준이 아닌 게 없어 그러면 여기 볼랜드에 시불불 컴파일러, 비주얼 시플불의 컴파일러 gnu 1불뿔 컴파일러에 다 실행 파일을 만들면은 실행 파일 만들어서 컴퓨터에서 동작시키면은 다 동일한 동작을 한다.
그런데 예를 들어서 이런 겁니다. 표준을 따르지 않는 이거 비디오 10불불 전용 컴파일러야 이거 그러면 이걸 갖고 이제 컴파일러 하면은 비주얼 시플플은 이게 뭔지 알아요 이게 그렇기 때문에 실행 파일을 만들 수 있는데 볼랜드나 gnu 쪽에서 몰라요.
그러면 실행 파일을 만들 수 없고 얘네들은 이제 에러를 냅니다.
지원하지 않습니다. 그래서 여러분들 뭐야 이런 거 최대한 이용하지 않는 게 좋은데 이용하지 않는 게 좋은데 그렇지만

18:48
아

18:49
꼭 사실 윈도우 상에서 작업하고 윈도우 상에서 앱을 만들고 윈도우 상에서 동작하는 서비스를 만들 거야 그게 확실히 정해져 있어 그럴 때는 사용해야죠.
그죠? 그런 게 확실하다면 사용하는 게 맞는데 그렇지만 특별한 이유 없이 비표준 구문을 사용하는 것은 지양해야 합니다.

19:18
다음은요 시불불 언어의 주요한 설계 목적입니다.
그러니까 시불불 언어를 개발을 할 때 목표로 한 겁니다.
그래서 첫 번째 주요 목표는요. c 언어와의 호환성입니다.
그래서 c 언어의 문법 체계를 계승했습니다. 그래서 c 언어로 작성한 소스 코드라든지 아니면 바이너리 파일이라든지 모두 다 가져다가 시불플릿을 사용할 수 있어 그래서 구분을 해보면 소스 레벨 호환성입니다.
그리고 기존에 작성된 c 프로그램을 그대로 가져다 사용할 수가 있습니다.
그러니까 예를 들어서 뭐 c로 돼 있어 점 c 파일이 있어 c 파일이 있고 점 CPP 파일이 있어 그럼 여기서 이만큼 오려다가 함수라든지 아니면 뭐 클래스 스트럭처라든지 그런 걸 가져다가 여기 여기다 이렇게 이식해 그러면 이 부분에 맞게 동작하면서 에러가 안 나고 그냥 동작을 하는 거죠.
링크 레벨 호원성인데요. 이거는

20:19
여러분 코드 c는 텍스트 파일이잖아요. 텍스트 파일에서 붙일 수도 있고 근데 링크는 c 목적 파일과 라이브러리 둘 다 이제 컴파일 된 결과죠.
그 컴파일된 결과를 c불 프로그램에서 링크해서 그냥 실행할 때 같이 읽어다가 한꺼번에 실행할 수가 있습니다.
그걸 링크라고 하는데 나중에 얘기하도록 하겠습니다.
그래서 소스 레벨에서 갖다 붙일 수도 있고 컴파일 된 링크 레벨에서도 컴파이드된 결과를 링크 레벨에서도 호환성을 지원할 수가 있습니다.
다음은 객체 지향 개념 도입인데요. 객체 지향이라고 하면은 일단 캡슐라 상속 다양성 등이 있거든요.
이거 뒤에서 자세히 나오는데 이런 것들을 지원을 해서 소프트웨어 재사용을 통한 생산성 향상 또 복잡하고 큰 규모의 소프트웨어 작성 관리 유지 보수에 용이합니다.
이게 사실 아까 요 예에서 보면은 요만큼을 긁어다가 붙이는 게 쉬운 것처럼 얘기했지만 쉽지 않다.
이게 진짜 독립된 코드는 이렇게 갈 수 있지만 이게

21:29
c 파일 보면 쭉 길게 이어지는데 쭉 길게 이어지는데 그중에서 독립되는 부분은 여기 여기 여기 이렇게 분석을 해야겠죠.
분석해다가 이렇게 갖다가 넣어 이제 이게 쉽지 않습니다.
그래서 그냥 아예 파일을 만들 때 이렇게 이제 하면 이 부분은 독립된 구역 그러면 이거를 이제 정의하는 겁니다.
시플플에서는 예를 들어서 여기 클래스라든가 대표적인 클래스라든가 스트럭처도 원래 있긴 했지만 다양성 같은 거 이렇게 해서 독립된 구역 대표적으로 클래스 템플릿 클래스 템플릿 함수 뭐 이런 것들 가져다가 이 독립된 구역을 그대로 이게 이게 c라면은 CPP로 CPP로 독립된 구역을 갖고 옵니다.
그래서 이 독립된 구역을 가져다 쓰고 싶고 실행할 때도 독립되게 실행할 수 있고 이렇게 만드는 거 이런 걸 통해서 재사용을 쉽게 했고요.
재사용이 쉬워지니까 옛날에 만들어놓은 거 다시 사용할 수 있겠죠.
그래서 이게 생산성이 향상된다고 향상된다고 하는 겁니다.
그리고

22:38
당연히 그러니까 복잡하고 큰 규모의 소프트웨어 작성 관리 유지 보수가 편해지겠죠.
그죠? 독립된 부분을 가져다 쓰고 또는 교체하고 이런 게 가능하니까요.
그리고 컴파일링 할 때 전체를 한꺼번에 본다고 했죠.
그때 근데 타임이 안 맞으면 얘 바로 에러 냅니다. 근데 꼭은 아니야 예를 들어서 인티저를 플러스로 변환하고 이런 거는 그냥 지원을 합니다.
그렇지만 워닝은 하겠죠. 그렇지만 실행할 때 지원하지 않는 타입 타입이 안 맞은 경우에 바로 컴파일 에러를 주고 타입이 안 맞습니다 하고 그냥 컴파일 될 때 그 에러가 실행 파일 안 만들고 에러 딱 리턴하고 끝내버립니다.
그래서 실행 시간 오류 가능성을 줄입니다. 뭐야 타입이 안 맞아도 야 일단 컴파일링해 그다음에 실행할 때 뭐 두고 볼게 이렇게 안 해 그래서 컴파일 할 때 오류가 많이 나지만 그렇지만 실행할 때는 오류가 잘 안 난다.
그리고 또

23:35
일단은 타입 때문에 실행할 때 타입 때문에 오류 나는 경우가 꽤 있어요.
다른 언어에서 그렇지만 얘는 그런 게 없기 때문에 디버깅이 좀 편리하다.
근데 요게 일장일단이 있어 그러니까 여러분이 코드를 짤 때 코드를 짤 때 타입을 딱딱딱 맞춰서 짜줘야 돼.
그렇지 않으면은 컴파일 할 때 에러가 나 그러니까 그런 것까지 생각하다 보면은 코드 짜는 게 그래도 어느 정도는 좀 더 어려워지겠죠.
그렇지만 그거를 잘 지키다 보면 동작하는 데 있어서는 큰 이점이 됩니다.
또 코드 짤 때 코딩 할 때 그것을 안 맞춰서 짜면은 코딩 타이핑하기 편해.
그렇지만 실행할 때 그 에러가 만약 타입 에러가 나면 찾기는 힘들어.
그래서 여기 1장 1단이 있는데 아무튼 시불불은 그거를 엄격하게 지키는 편이다.
그래서 실행 시간 효율성 저하 다음 내용인데요. 예를 들어서 이거 1라인이라는 1라인이라는 함수 문법인데 함수가 실행하다가

24:39
짧은 함수 함수를 호출하면 이렇게 실행 라인 넘어가서 이렇게 다른 함수에서 갔다가 이렇게 넘어오는 거 이렇게 됩니다.
이게 예를 들어서 메인 함수였다 메인 함수 실행하다가 여기 에드 함수를 불러 그럼 여기서 예를 들어서 a 플러스 b 이렇게 하는 에드 함수가 있다고 해보면 이렇게 넘어가서 더하고 그 결과를 받고 다시 실행해 이렇게 하면은 사실 a 더하기 b는 아주 간단한 건데 이렇게 점프 점프해서 두 번을 분기를 해야 되거든요.
실행하는 위치를 두 번을 바꿔줘야 돼. 근데 요 자체가 큰 부담입니다.
이렇게 실행하는 위치를 점프 점프 해주는 게 그래서 이런 거를 야 이렇게 해서 점프 점프해서 넘어가지 말고 이렇게 실행하다가 그냥 이 부분 있죠.
a 더하기 b를 그냥 여기다 코드 자체를 넣어버립니다.
메인 함수에다가 코드 자체를 넣어버려서 그냥 메인 함수 안에 있는 코드처럼 이렇게 해서 쭉 실행하게 하는 게 1라인 규칙이야 그래서 이런 걸 통해서 실행 시간에 실행

25:36
시간의 효율성 저하를 최소화했다 그러니까 효율적으로 실행한다라는 얘기죠.
그래서 이런 거 이런 걸 지원하기 위한 인라인이라는 이 기능을 구현하고 있습니다.
이게 초창기에는 되게 유용했거든요. 근데 요새는 최적화를 하면서 이걸 자동으로 해줘요.
좀 자동으로 해주는 편이라 최근에는 요 1라인 넣고 안 넣고의 차이가 그래도 많이 줄어든 편입니다.

26:02
시플풀이 시어어와의 호환성을 중요시하긴 하지만 기존 시어너에 그래도 몇 가지 기능들을 추가를 했습니다.
대표적으로 추가한 기능들 요거 한번 보도록 하겠습니다.
첫 번째가요. 함수 중복입니다. 예전에는 c언어에서는 함수 이름이 같으면은 뭐 인자나 뭐 아무 리턴이나 상관없이 하나의 이름으로는 하나의 함수만 있을 수 있었거든요.
그렇지만 10불에서는 매개 변수의 개수나 타입이 다른 동일한 이름의 함수를 선언할 수 있습니다.
예를 들어서 에드 인테인트 받는다 이런 게 있으면은 이것도 할 수 있고 똑같은 애드지만 하나는 플로 하나는 엔테인트 하나는 플롯 플롯 플롯 해서 이 두 가지를 다 선언하고 사용할 수가 있다.
다음은 디폴트 매개 변수인데요. 디폴트 매개 변수는 예를 들어서 이 함수 볼까요? 이거면 애드 2 더하기 1 해서 이런 함수가 있다고 할 때 뒷부분이 항상 1이 들어온다든가 아니면 공통적으로 값이 들어온다 그런 경우에는 그냥

27:21
에드 2라고 하면은 하고 닫아버리면은 이 두 번째 변수 요 두 번째 변수 이게 항상 1이라고 가정을 하는 거예요.
그러니까 값을 주면은 준 값을 사용하고 값을 주지 않으면은 기본 값으로 선언된 값을 사용하는 거죠.
이런 걸 우리는 디폴트 매개 변수라고 합니다. 그리고 참조와 참조 변수인데요.
하나의 변수가 있으면은 3이면은 여기를 a를 통해서 a는 3 a라는 변수를 통해서 이 위치를 가리키기도 하고 또는 b라는 변수를 선언해서 이 위치를 가리키기도 하고 동일한 변수인데 동일한 메모리 공간인데 여러 이름을 가질 수 있게 하는 이런 게 참조와 참조 변수입니다.
다음에 참조에 의한 호출인데요. 함수를 호출을 할 때 그냥 요 값을 그냥 값으로 주지 않고 참조로 써줘요.
그러면은 함수 호출할 때 참조로서 어떤 변수를 전달을 하면은 그 함수 안에서 사용하는 변수가 외부에 있는 그 위치 이 위치를 가리키게 되는 거죠.
이거 좀 어렵다 말하는 게 그러니까 참조를 이용해서 함수의 인자를 전달하는 게

28:40
참조에 의한 호출입니다. 이거 이거 구체적인 건요.
여 뒤에 나오니까 그때 더 얘기하도록 하겠습니다.
그리고 예전에는 메모리 얼룩이라 그래서 m 얼룩 말록 그리고 말로까

29:06
그렇죠 옛날에는 메모리 얼룩 할 때 말록과 그리고 프리였죠.
이 두 개를 갖고서 메모리를 풀렀다 잡았다 풀렀다 했는데 여기 1플플에서는요 요 뉴와 딜리트를 했습니다.
거의 비슷한데 약간 차이는 있습니다. 아무튼 그래서 뉴와 딜리트를 가지고서 메모리를 동쪽 메모리를 할당하고 해제하는 이런 기능을 구현을 했고요.
다음은 연산자 재정인데요. 이거 뒤에서 나옵니다.
예를 들어서 더하기인데 지금은 숫자만 더하죠. 1 더하기 2 기본적으로 이런 거 1.0 더하기 2.1 이런 거 하는데 이런 거 말고도 그냥 문자열 더하기 문자열 클래스 더하기 클래스 이런 거 새로운 그런 연산자 동작을 정의해서 사용할 수가 있습니다.
다음 제너릭 함수와 클래스인데요. 일단 클래스라는 개념을 도입을 했고요.
이 클래스 키워드를 통해서 클래스라는 키워드를 통해서 어떤 동작이나 어떤 메모리 이런

30:08
하여튼 관계가 있는 것들을 한 군데 다 클래스라는 그 덩어리를 통해서 다 모아놓는 겁니다.
이런 걸 구현을 했고 또 제너릭 함스는요.

30:18
아

30:19
아까 여기서 보면 인트 같은 것도 인트 인트 플로 플롯 이렇게 해서 여러 개를 선언을 해야 되죠.
그럼 이거 뭐야 인트인 플로플롯만 해야겠어요? 캐릭터 캐릭터 더블더블 롱롱 롱 롱 이런 식으로 해서 여러 가지 선언을 해야 되잖아요.
그러니까 똑같은 거를 여러 번 선언하는 것을 그러지 말고 그냥 여기 동작을 정의를 하고 요 들어오는 인자는 그냥 호출할 때 적어주는 인자에 맞게 그냥 유출을 해내자 이런 게 바로 제너릭 함수입니다.
이것도 뒤에서 나오니까 그때 좀 더 설명을 덧붙이도록 하겠습니다.
아무튼 그래서 c언어에 이런 기능들을 더 추가를 해서 씨불불 문법을 좀 더 보강을 했죠.
다채롭게 했습니다. 그래서 시불불이요 문법이 훨씬 많고 배우기도 어렵습니다.
네 솔직히 어렵고 그렇지만 뭐 다 배우고 나면은 좀 뭐랄까요? 내가 구현할 수 있는 게 좀 사용할 수 있는 문법의 가짓수가 늘어나니까 좀 더 구현하기는 편하다는 장점이 있습니다.

31:27
c플 여러 기능들이 들어갔지만 그래도 제일 가장 강조가 되고 있는 게 클래스죠.
그리고 객체 지향 op라고 하는

31:38
객체를 사용해서

31:41
소스 프로그래밍을 한다. 이게 이제 가장 두드러진 특성이고 그럼 이런 객체 지향 때문에 생기는 특성 중 대표적인 게 캡슐 하나 있습니다.
이런 캡슐화 특성을 보면요. 데이터 그리고 또는 함수입니다.
함수를 캡슐로 싸서 외부에서로부터의 접근으로부터 외부의 접근으로부터 보호한다.
이게 캡슐라고요. 캡슐라 이런 특성이고요. 시플풀에서는요 클래스를 이용하고요.
그 클래스를 프로그래밍 할 때 사용하는 문법은요.
이 클래스입니다. 이 클래스라는 키워드를 붙이고 그다음에 이제 내용을 적으면 이게 하나가 한 덩어리가 되는 겁니다.
그래서 이렇게 캡슐라를 하는데요. 그럼 맨날 나오는 게 이제 클래스라는 말이 나오면 따라다니는 게 객체인데요.
클래스는 객체를 만드는 틀이라고 정의를 하고 객체는 클래스라는 틀에서 생겨날 실체 어떤 특정 물체 이런 걸 갖고 이제 객체라고 합니다.
그 말이 그 말 같아요. 이제 그림으로서 설명을 해보면

32:52
이런 붕어빵 틀이 있을 때 이 틀 안에다가 이제 밀가루 같은 걸 부어 그러면 이제 붕어빵이 구워져서 이렇게 나오겠죠.
그럼 이렇게 나온 붕어빵들은 객체라고 하고요. 이 객체를 만들 때 사용했던 틀 요 붕어빵 틀은 이걸 클래스라고 합니다.
결국 클래스라는 거는 어떤 실질적인 어떤 물체가 아니에요.
어떤 물체를 만들기 위해 정해놓은 규칙 이런 게 클래스가 되는 거고요.
이 객체라는 거는 이 클래스를 이용해서 실제 메모리에 들어가는 실제 물체를 만들어낸 결과물 이런 게 우리는 이제 객체라고 합니다.
근데 말을 좀 혼용하는 게 객체라는 말 대신에 실체는 잘 안 쓰는 것 같은데 인스턴스라는 말은 잘 씁니다.
객체 오브젝트 대신에 인스턴스 이런 거 다 똑같은 말입니다.
그래서 클래스와 반대되는 반대되는 건 아니죠. 결과물 객체 오브젝트 인스턴스 이거 다 같은 뜻으로 사용하고 있습니다.
예를 보면요.

34:00
실제 시플플 코드입니다. 그럼 여기다 클래스라는 키워드를 적고 내가 원하는 이름을 적어줘요.
그러면 얘네들은 서클이라는 클래스가 되고요. 이게 덩어리로 묶어줍니다.
그럼 이 안에 있는 게 하나의 약속이 되죠. 그럼 이 약속을 갖고서 이제 클래스를 이제 틀을 만들었고 클래스를 만들었고 이걸로 이제 실제 만들어줘 어떤 오브젝트 객체 만들어주면 이런 요놈 빵 요놈 빵 요놈 빵 이런 1 1 1 이런 걸 만들어주는 걸 이런 걸 오브젝트라고 하는 거죠.
그래서 예를 들어서 간단히 얘기하면 그냥 이렇게 한번 생각을 해볼까요? 인트 a 이렇게 하면은 이거 미리 정해놓은 타입이 타입이었고 이 타입에 해당하는 변수를 만든 게 a였죠.
a가 실체고 이거는 이제 어떤 약속이죠? 자료형 약속입니다.
그러면은 클래스도 여기 이렇게 씁니다. 이렇게 하면 서클

34:58
뭐

35:00
b 이렇게 할까요? 이렇게 하면은 이게 클래스가 되고 이게 객체가 됩니다.
결국 뭐예요? 클래스라는 거는 어떤 실질적인 요 변수 같은 실체 오브젝트를 만들기 위한 약속의 서클이고 이 뒤에 있는 요 b가 이제 객체가 되겠죠.

35:24
다음 특성은요. 앞에서 말한 상속 앞에서 말한 클래스 캡슐라가 있고 다음은 두 번째 특성은 상속성입니다.

35:37
객체 지

35:39
객체 지향 상속은요. 자식이 부모의 유전자를 물려받는 것과 유사합니다.
결국 부모가 가진 어떤 특정한 변수라든가 함수라든가 이런 걸 물려받는 것을 우리는 상속이라고 하고 이런 특성이 있다 그래서 상속성을 가지고 있다라고 얘기를 합니다.
그래서 시불불에서의 상속은요. 객체가 자식 클래스의 멤버와 부모 클래스에서 선언된 모양 그대로의 멤버들을 가지고 탄생하는 겁니다.
그러니까 무슨 말이에요? 자기의 멤버와 모 부모 클래스의 멤버를 가지고서 태어나는 걸 우리는 시플플에서 상속이라고 한다.
그림으로 보면요. 일단은 가장 간단한 이런 전화기가 있다고 해보죠.
전화기의 기본 기능은 전화 걸기 전화 받기가 있었습니다.
다음에 이제 휴대전화기 좀 더 발전을 했어. 그래서 유선이 아니라 이제 들고 다니는 전화기입니다.
그러면 얘는 전화 걸기받기와 무선 기지국 연결하기 배터리 충전하기 이런 기능들이 추가로 있어야겠죠.
그런 다음에 이제 더 발전하면은

36:46
휴대전화기인데 노래를 들을 수 있다고 해볼까요? 음악 기능을 가진 전화기야 그러면은 무선 전화기 기능에다가 음악 다운받기 음악 재생하기 이렇게 있어야 됩니다.
그러면 이제 상속 관계를 그려보면은 폰이라는 클래스가 있고 거기에 두 개의 기능을 갖고 있습니다.
멤버 함수를 갖고 있습니다. 전화 걸기 전화 받기 다음에 이제 모바일 폰을 만들 거야.
근데 모바일 폰도 이제 처음부터 만들지 말고 폰에 있는 요 두 기능은 그대로 갖고 오고 거기다 2개를 추가하는 거죠.
무선 기지국 연결하기 배터리 충전하기 그래서 위에 걸 상속받으면은 있는 건 쓰고 새로운 것만 더하면 됩니다.
뮤직폼 같은 경우에는 다시 위에 있는 모바일 폰을 상속을 받고요.
거기다가 음악 다운받기 음악 재생하기를 만들면 돼.
그럼 이 안에 들어 있던 게 2개가 아니라 4개가 들어있었죠.
그럼 4개가 싹 들어가는 거야 이런 식으로 상속을 받음으로써 기능들을 계속 더해 나갈 수가 있습니다.
이거를 이제 10

37:48
c불불로 실제 코드로 적어보면은 클래스 폰을 만들고 이 안에다 이제 두 개의 함수를 넣니다.
콜과 리시브를 넣어요. 그다음에 클래스 모바일 폰을 만드는데 얘는 모든 걸 새로 만들기보다는 기존에 있던 콜과 리시브는 그대로 이용하고 싶어 그러면은 야 나 이전에 있던 폰에 있던 거 그대로 갖고 올 거야라는 요 규칙이 이겁니다.
요 땡스고 콜론이죠. 콜론 쓰고 퍼블릭 그다음에 폰 이렇게 하면은 폰을 퍼블릭 타입으로 상속을 받을 거야라는 문법입니다.
그러면 요 폰에 있던 게 요 두 개 있죠 요게 이렇게 해서 이 안에 쏙 들어갑니다.
그러면 상속받은 2개의 함수를 갖고 오고 내가 갖고 있는 2개의 함수 코넥 와 그리고 리차즈라는 두 개의 멤버 함수가 있죠.
그럼 모바일 폰에는 2개만 여기 두 개만 써 있지만 실질적으로는 이 안에 4개가 들어가는 겁니다.
다음 이제 뮤직폰을 만들 때 보니까 얘도

38:52
땡 하고 퍼블릭 타입으로 모바일 폰을 상속을 받습니다.
그럼 모바일 폰 안에 지금 4개 들어 있었죠 여기 4개가 들어있었습니다.
그럼 4개가 다시 상속받아서 이렇게 들어옵니다.
그러면은 거기다가 4개 그냥 들어오고 다운로드 뮤직 플레이 이렇게 되는 거죠.
이 관계를 생각을 해보면 모바일 폰을 만들 때 보면은 그냥 요만큼만 써주면은 지워볼까요? 모바일 폰을 만들 때 퍼블릭 모바일 폰 요만큼만 써주면 결국 어떻게 돼요? 이 4개의 함수 이거 안 써도 그냥 자동으로 들어가잖아요.
이렇게 해서 구현할 때 되게 편해지죠. 빠르고 효율적으로 됩니다.
그래서 상속이 매우 현 시대의 소프트웨어 개발할 때 개발 시간을 많이 줄여주는 그런 특성입니다.
이런 식으로 해서 이제 상속을 받으면서 최종 결과물 뮤직폰을 작성할 수가 있습니다.
다음 특성은요. 다양성입니다. 다양성은 폴리 모피즘이라고 얘기를 하고요.
좀 풀어서 설명을 하면은

40:03
하나의 기능이 경우에 따라 다르게 보이거나 다르게 작동하는 현상을 우리는 폴리 짐이라고 합니다.
다양성이라고 하고 대표적으로 연산자의 중복 함수의 중복 함수의 재정의 이런 것들을 우리는 이제 다양성의 종류가 되는데요.
예가 되는데요. 예를 들어서 우리가 아는 거는 2 더하기 3은 알고 있어 더하기 연산자를 보면은 2 더하기 3 하면 항상 숫자 더하기 숫자에서 5가 돼 아는 거죠.
근데 남자 더하기 여자 이거 남자 문자열 더하기 여자 문자열입니다.
그래서 문자열 더하기 문자열 하면은 그냥 문자열을 붙여줘라 이런 걸 새로 정의할 수가 있겠죠.
이게 이제 새로 정의된 더하기 연산자의 기능이 되겠죠.
그다음에 레드 객체 블루 객체를 더해 그럼 이거 그럼 어떻게 되냐 그러면은 퍼플 컬러가 나옵니다.
그러면 색을 더하기라는 건 두 색을 섞었을 때의 결과색이 나오게 하는 거구나.
그럼 이런 건 완전 새로운 기능이죠. 그리고 이런 기능들을 우리가 실제로

41:14
추가로 구현할 수가 있습니다. 그래서 연산자의 추가적인 기능들을 계속 더해나가는 이런 연산자 중복 기능을 구현할 수가 있어요.
이걸 우리 다양성의 한 종류고요. 다음에 AD 함수 아까 얘기했죠.
이렇게 변수 인트 더하기 인트 또는 인트인트 인트에서 3개 더하기 또는 인트 더블 더하기 이렇게 해서 인자를 가지고서 여러 함수들을 만들 수 있다라고 해서 중복이라고 합니다.
이런 걸 우리 오버 로딩이라고 하죠. 그래서 펑션 오버로딩을 통해서 여러 같은 이름의 여러 연산을 정의하는 그런 걸 통해서 다양성을 또 지원하기도 하고요.
다음은 동물이라는 클래스가 있다고 해볼까요? 그 안에 이제 목소리 내기라는 함수가 있었어.
그럼 얘를 상속받아서 강아지도 만들고 고양이도 만들고 닭도 만들어 그렇지만 소리 내기 같은 경우는 각 동물마다 다르겠죠.
그러면은 똑같은 함수지만 상속받은 애들이 다르게 정의를 할 수 있습니다.
얘는 멍멍으로 얘는 야옹으로 얘는 거고 이런 거 같은 함수인데 상속받은

42:20
자식 클래스에서 다르게 정의하는 거 이런 걸 우리는 함수 재정이라고 하고요.
영어로 표현하면 오버 라이딩이라고 합니다. 이거는 오버 오버 로딩 로딩이고요.
이게 좀 헷갈려요. 영어 단어가 그러니까 할 때 같이 외워두세요.
중복은 오버 로딩 재정의는 오버라이딩 이렇게 표현을 합니다.

42:46
시플플 언어에서 이제 아까 말했듯이 시플에서 가장 두드러지는 특성이 객체 지향이죠.
그럼 왜 객체 지향으로 넘어왔을까? 물론 그러니까 c 잘 이용하고 있었어요.
근데 c를 계속 이용하다 보니까 불편한 점이 있었습니다.
이게 뭐냐면 너무 코드가 길어지니까 이거를 분석하기도 힘들고 갖다 쓰기도 힘들고 딴 데다 이식하기도 힘들고 그런 거예요.
그래서 시플불을 만들면서 좀 객체 지향을 도입한 이유가 소프트웨어의 생산성을 향상시키고자 했습니다.
일단 소프트웨어 생명주기 단축 문제 해결 필요했습니다.
예를 들어서 만들고 만드는 데 너무 오래 걸리는 거야.
예를 들어서 아까 같이 뮤직폰을 만든다고 그러면은 뮤직폰을 무조건 뭘 만든 다음에는 대부분의 경우 갖다 쓰는 경우가 있긴 했죠.
그렇지만 많은 경우에 그냥 바닥부터 다시 하는 겁니다.
그러니까 이게 너무 힘들어 한 번 이렇게 처음부터 끝까지 쭉 생산하는 데까지 드는 시간이 너무 길어.

43:52
그래서 기 작성된 이미 어느 정도 해놓은 게 항상 있는데 그거를 최대한 잘 갖고 와 보자.
일단 내가 만들 때는 귀찮지만 이번에는 귀찮을지언정 다음번에 개발할 때 내가 이번에 개발해놓은 코드를 좀 갖고 오기 쉽게 하자 그래서 클래스로 만드는 겁니다.
그래서 기 작성된 코드 코드 재사용을 재사용을 꼭 해야겠다라는 목적을 갖고 만든 게 객체 제향이고요.
그래서 대표적인 방식이 c불불 클래스 상속 및 객체 재사용으로 해결을 했습니다.
일단은 요게 일단 클래스가 있으면은 클래스 자체를 재사용하는 것도 있고요.
또는 클래스를 재사용할 때 그냥 그 클래스를 사용하는 것 와 또 상속을 받아서 이전에 있던 클래스를 상속을 받아서 계속 안에 들어갔죠.
이 두 가지 방식을 통해서 소프트웨어의 생산성을 향상시켰습니다.
또 실세계에 대한 쉬운 모델링 과거의 소프트웨어는요.
수학 계산이나 통계 처리에 편리한 절차 지향 언어가 적합했습니다.

45:03
그러니까 뭐야 그냥 뭐 수학 문제 풀듯이 그냥 일자로 쭉 그냥 단순히 시간축으로 그러니까 라인 바이라인으로 하나하나하나하나 따라가면서 절차적으로 실행하는 그런 방식이 대부분이었거든요.
그런 경우가 많았거든요. 그래서 이런 경우에는 과거에 그 c 타입의 그런 코딩 스타일이 맞는데 현재 소프트웨어는요.
물체 혹은 객체의 상호작용에 대한 묘사가 필요했습니다.
예를 들어서 뭐 게임 같은 경우에 뭐랄까 유닛이 있고 이 전사 전사라는 유닛이 있고 마법사라는 유닛이 있고 저기 MPC라는 유닛이 있어 그럼 각 유닛마다 서로 이렇게 주고받으면서 게임이 진행되잖아요.
서로 이렇게 상호작용을 하죠. 그러면은 일단은 상호작용을 순서대로 쓰기가 힘들어 왜냐면 그거는 만약에 MPC야 그럼 그나마 좀 쓸 만한데 만약 유저를 내가 조종하는 어떤 캐릭터야 그러면은 그걸 여러분들이 절차적으로 프로그래밍 할 수 있을까 없죠.

46:17
유저가 조종하는 거잖아요. 그렇기 때문에 그냥 이 사람에 대해서 전체에 필요한 전사에 대한 전체적인 내용을 적어놓고 얘는 마법사 전체 적어놓고 얘는 MPC 전체적인 내용을 적어놓고 유저가 선택하면 여기 있는 게 얘한테 날아가고 여기 있는 게 얘한테 날아가고 서로 대화라든가 아니면 공격과 수비라든가 이런 걸 주고받으면서 작업을 해야 되죠.
그래서 실질적인 현실 세계는요. 그 시간에 따라서 정해진 그 패턴이 쭉 흘러가는 게 아니라 어떤 객체들이 있고 이 객체들 간에 상호 주고받는 식으로 동작하는 게 훨씬 더 현실 세계와 현실 세계를 묘사하는 데 적합합니다.
그래서 이런 객체 지향이 이런 데 아주 좋단 말이에요.
각 오브젝트별로 이렇게 묶을 수가 있으니까 그래서 실세계는 객체로 구성된 세계이기 때문에 객체를 중심으로 하는 객체 지향 언어가 현실 세계를 반영하는 데 더 적합하다는 겁니다.
근데 이걸 좀 얘기하다 보니까 무조건 시플풀이 좋다는 식으로 자꾸 얘기하게 되는데

47:20
꼭 그런 건 아니다. 그리고 그거는 케이스 바이 케이스입니다.
어떤 경우에는 그냥 단순한 동작을 하는 그런 소프트웨어를 개발을 하면 돼 그럴 때는 오히려 시플불이 귀찮아요.
그 단순하게 그냥 c만 갖고서 조금 절차적으로 작성을 하는 게 더 편할 때도 많이 있습니다.
절차 지향 프로그래밍과 객체 지향 프로그래밍을 보면요.
만약에 이런 자판기야 그럼 얘를 여러분이 이제 작업을 할 거야 그러면은 이 메인 함수 시작을 한다고 하죠.
요 시작을 하고 동전 입력을 받고 돈이 충분한가를 보고 얘 아니요 해서 아니면은 일로 가고 다시 상품 선택 이거 유저가 선택을 하겠죠.
그다음에 재고가 있나요? 봐서 없으면은 다시 선택하라 그러고 있으면 내려가고 그다음에 만약에 다 이제 됐어 그럼 상품이 되고 그다음에 종료되면 다시 올라가고 다시 시작하고 동전 입력하고 이런 식으로 이제 짜면 됩니다.
이게 실제 자판기에 들어가는 코드가 아마 이렇게 되어 있을 겁니다.
물론

48:24
여러분 코드 요 내용을 소프트웨어로 작업해도 되지만 이걸 하드웨어로 이거를 프로그래밍 해도 됩니다.
프로그래밍은 소프트웨어로도 할 수 있고 하드웨어로도 할 수 있어요.
어쨌든 이런 절차적인 것을 작업해놓은 소프트웨어든지 하드웨어든지 이런 게 절차 지향 프로그래밍 이런 식으로 작업이 되어 있다.
근데 객체 지향으로 이거를 짜면은 일단은 자판기 전체 엔진이 있고요.
그럼 전체 큰 테두리가 있는 거고 그다음에 돈통 따로 하나 있고 커피 통 있고 물통 있고 프린통 있고 커피 통 있어 그다음에 디스플레이 있고 버튼 있고 버튼 있고 버튼 있어 여러분이 다 객체야 그럼 버튼 클래스에서 버튼이 눌리면은 엔진 아테야 눌렸어 이렇게 줘.
그럼 얘가 눌렸어. 그러면 이게 뭐야 뭐랄까 커피를 눌렀구나 이 버튼이 그러면 커피 통해서 커피 나오게 하고 물 나오게 하고 이렇게 연락을 주겠죠.
그다음에 디스플레이에는 커피 눌렀습니다. 주고요.
다음에 예를 들어서

49:22
어

49:24
다른 뭐랄까요? 음료수를 눌렀어 그러면은 음료수를 눌렀어 그러면 돈통한테 확인을 해야겠다.
돈통이야 돈이 들어왔냐 이렇게 물어보고 들어왔다 그러면 얘가 다시 오케이 돈이 들어왔으니까 통 통 아무튼 음료수가 나가게 하는 이런 식으로 이제 엔진이 이제 제어를 하고 각자 클래스하고 이제 주고받으면서 얘가 이거 누군가는 이걸 좀 이거 뭐야 정 뭐라고 그럴까요?

49:50
그

49:51
이런 전체적인 동작을 제어하는 어떤 엔진이 있고 얘가 이제 전체적인 걸 주고받고 하겠죠.
이것도 사실 네 코딩하기 나름인데 엔진을 둘 수도 있고 아니면 얘네들을 다 연결할 수도 있고 아무튼 그거는 자유입니다.
아무튼 절차 지향과의 차이를 보면은 각 객체들마다 다 어떤 클래스로 구현을 하고 클래스가 이제 주고받으면서 클래스별로 자기가 할 일을 전담이죠.
객체별로 어떤 일을 해야 되는지 정의를 해서 상호 이렇게 연동을 하면서 이 동작이 이루어지는 이런 식으로 작업을 하면 됩니다.
이거 얘를 봐도 사실 요 정도 문제는 이게 편한 것 같아 요 정도 절차 지하게 편한 것 같고 그렇지만 이게 이제 진짜 자판기가 아주 고급 자판기라든가 라면을 만드는 자판기라든가 아니면 뭐 100만 가지를 파는 온라인 판매도 지원하는 자판기라든가 이렇게 이제 복잡해지면은 이 절차가 엄청 길어집니다.
그래서 그런 경우에는 이제 이런 게 낫다 그죠? 여기는 그냥 여기 객체 하나씩

50:59
온라인 물건 이렇게 해서 객체 하나를 추가하면 되거든요.
그러니까 이런 게 더 이제 오히려 복잡한 환경에서는 이런 게 더 편해집니다.

51:15
다음은 제너릭 프로그래밍인데요. 대표적으로 시플불에서 지원하는 제네릭 프로그래밍요.
제네릭 함수와 제네릭 클래스가 있습니다. 제네릭 함수는요.
동일한 프로그램 코드에 다양한 데이터 타입을 적용할 수 있게 일반화시킨 함수입니다.
예를 들어서 아까 헤드 인트 인트 헤드 플롯 플롯 예를 들어서 이게 이제 여기 쭉 있잖아요.
더블 더블도 있고 아니면 인트 플롯 플롯 인트 이렇게 섞을 수도 있잖아 이거 똑같은 일하는 건데 이 함수를 맞지 10개 만들어야 되는 거 아니야 모든 경우를 대처하기 위해선 그래서 얘를 그냥 변수를 그냥 임의의 변수로 해놓고 들어올 때 임의의 타입의 변수를 해놓고 실제 호출하는 부위에서 들어온 변수의 타입에 맞게 동작을 하자 그게 제네릭 함스입니다.
그래서 간단하게 애드 t 콤마 티 이런 식으로 합니다.
그래서 타입을 t라고 해놓고요. 제 호출하는 부에서 들어온 타입에 맞게 티가 인트든 플롯이든 이렇게 변화를 합니다.
이렇게 제너릭 함수고 제너릭 클래스 얘도

52:32
동일한 프로그램 코드에 다양한 데이터 타입을 적용할 수 있게 일반화시킨 클래스입니다.
예를 들어서 얘도 에드라는 클래스야 그러면은 초기화할 때 인트인트 받을 수도 있고 플로 플롯 받을 수도 있고 이런 식으로 입력되는 거에 따라서 그 두 값을 더해서 돌려주는 그런 클래스가 있다고 할 때 얘도 이거마다 만들 수는 없잖아요.
들어오는 생성자 안에 들어오는 이런 타입의 타입마다 클래스를 만드는 건 비효율이죠.
그렇기 때문에 얘도 그냥 만들 때 TT 이렇게 적어주고 이것도 생성자에 넣어준 요 값을 보고서 그러니까 클래스의 객체를 만들어줄 때 입력되는 변수의 타입을 보고서 클래스를 생성을 해줍니다.
그래서 제너릭 함수와 제너릭 클래스가 CFF의 대표적인 제너릭 프로그래밍 종류입니다.
그래서 요 둘을 할 때요. 템플릿이라는 키워드를 사용하고요.
이건 규칙입니다. 요 앞에다가 요 사무소 앞에다가 템플릿 이렇게 붙여줍니다.
그래서 이런 키워드 선언하는 게 있고요. 제나

53:39
캄수 제네 클래스 이거를 처음 들어본 사람은 이거 진짜 좋은데 이렇게 생각들 수 있습니다.
옛날에 진짜로 그래 좋아요. 이렇게 생각을 했고 많은 데서 도입을 하고 있고 그래서 이런 개념을 시플만 지원하는 건 아니고요.
자바나 시샵 요런 다른 언어에서도 동일한 개념이 있습니다.
문법은 조금 다르겠지만 그래서 이런 제너릭 감사와 제네릭 클래스를 사용하는 방식을 제네릭 프로그래밍이라고 합니다.
제네릭 프로그래밍 다시 한번 정의를 해보면 제네릭 함수와 제네릭 클래스를 활용하여 프로그램을 작성하는 새로운 프로그램 패러다임을 말합니다.
이게 근데 나온 지 좀 됐죠. 이것도 이거 처음 나왔을 때는 새로운 맞는데 그냥 프로그램을 작성하는 프로그래밍 패러다임을 우리는 제너릭 프로그래밍이라고 한다.
이것도 한 10몇 년 전에도 다 그렇게 얘기했으니까요.
네 그렇게 하고 아무튼 중요성은 점점 증가하고 있다.

54:41
어쨌든 간에 하나의 알고리즘적인 코딩을 하나만 해놓으면 모든 변수에 적용할 수 있기 때문에 여기저기서 점점점 도입을 해 나가고 있습니다.

54:56
다음은 시플플 언어의 장점이자 단점인데요. 시플플 언어는 c 언어와의 호환성을 추구한다.
아까 얘기했죠. c 언어 그대로 텍스트 레벨이든 바이너리 레벨이든 파일 레벨이든 다 지원을 한다고요.
그러니까 장점은 기존에 개발된 c 프로그램 코드를 다 활용할 수 있다는 거고요.
단점은 c에 있는 모든 문법을 적용 도입을 하다 보니 캡슐라 원칙이 무너집니다.
예를 들어서 글로벌 변수 같은 경우를 안에서 클래스 내부에서 사용하면 독립적이지 않죠 글로벌 변수에 좀 영향을 받잖아요.
뭐 이런 거 그런 것도 있고 그리고 씨불불에서 전역 변수와 전역 함수를 사용할 수밖에 없음 그렇죠 왜 전역 변수 전역 함수를 사용할 수밖에 없냐고요.
이게 시에서 지원을 하기 때문에 씨불에서도 지원을 하는 겁니다.
그래서 이런 것들을 좀 싫어하는 사람들이 있어요.
그래서 그러니까 여러분이 이제 코딩 시불불 코딩을 한다면은

55:57
c 지원을 하긴 하지만 클래스를 사용할 거면 이런 걸 최대한 클래스 내부에서 최대한이 아니죠.
무조건 저는 거의 무조건입니다. 무조건 사용하지 않는 것을 권장합니다.
만약에 여러분들이 저녁 함수와 저녁 전역 변수와 전역 함수를 15%에서 사용할 거야 그러면 얘를 함수의 인자로 넘겨주세요.
그럼 그 인자를 받아서 그걸 사용하는 방식으로 코딩하면은 독립성이 깨지지 않습니다.
그래서 그런 식으로 작업하는 걸 추천을 하고요. 그래서 아무튼 이런 저녁 함수 저녁 변수 저녁 함수를 사용하면 부작용이 발생하죠.
저녁 변수가 바뀔 때마다 아이 바뀌어버리게 되니까요.
그래서 시플 프로그램을 작성하고 컴파일 할 때는요.
일단 편집할 때는 1불불 소스 프로그램은 텍스트 파일로 되어 있잖아요.
그러니까 텍스트를 수정할 수 있는 암호 텍스트 편집기로 편집이 가능합니다.
예를 들어서 진짜 메모장 갖고도 수정 가능합니다.

57:04
그래도 일반 문서와 일반 문서와 소스 코드 문서를 구분하기 위해서요.
그래도 확장자는 다르게 하고 있습니다. 그래서 1플풀의 경우에는 점 CPP라고 쓰고 있죠.
참고로 c 언어의 표준 확장자는요. c를 쓰고 있습니다.
이 둘 사이 구분을 하세요. 그래서 어떤 편집기는요 c로 하면은 c 언어 표준으로 컴파일을 하고요.
점 CPP로 하면은 1불 컴파일러로 컴파일을 하거든요.
그래서 요 확장자를 보고 컴파일러를 조절할 수도 있으니까 하는 것도 있으니까 이 CPP의 경우는 CPP로 적도록 합니다.
아까 말했듯이 아무런 텍스트 편집기로도 편집이 가능한 게 맞지만 그래도 가능하면요.
여러분들 c 플러스 플러스 통합 개발 소프트웨어를 이용하는 걸 추천합니다.
그러니까 CVP 개발을 위한 편집기를 사용하는 것을 추천을 하고요.
이런 경우에는 통합 개발 소프트웨어를 사용하면 소스 편집 컴파일 링킹 실행 디버깅 등

58:12
시플풀 개발하는 데 필요한 모든 기능이 다 들어있습니다.
근데 만약에 사용하지 않는 경우에는 따로따로따로따로 이렇게 해줘야 돼요.
그렇기 때문에 이런 통합 개발 소프트웨어 사용을 추천을 하고 대표적으로 비주얼 스튜디오를 사용을 하고 있습니다.
이게 뭐 아무튼 오래됐습니다. 비주얼 스튜디오가 시플플 개발에서는 거의 표준으로 사용되고 있으니까요.
우리도 이걸 사용하도록 하겠습니다. 다음 컴파일인데요.
컴파일은 씨뿔뿔 소스 프로그램을 소스라는 건 텍스트죠 토 소스 프로그램을 기계로 기계를 가진 목적 파일로 오브젝트 파일로 변환하는 것을 우린 컴파일이라고 합니다.
그러면은 CPP 파일을 컴파일 하면 OBJ 파일이 나옵니다.
그래서 이렇게 소스 프로그램으로 작성된 CP 파일을 기계어를 갖고 있는 오브젝트 파일로 바꾸는 것을 우리는 컵 파일이라고 합니다.
실제 컴파일한 결과를 보여주는데요. 요겁니다.
요

59:16
소스 코드 간단하죠. 그냥 헬로우를 출력하는 소스 코드인데요.
이거를 이제 컴파일을 해보면 이게 컴파일을 하면은 요 헬러 인트 메인 가로 여는 게 요만큼 코드로 변환이 되고요.
그다음에 STD 땡땡 c아우 헬로가 이렇게 기계어로 리턴 영이 이렇게 그리고 이제 프로그램이 끝나죠.
그래서 엔도 이렇게 해서 기계화로 하면은 실제로 이거 뭐예요? 이거 55 8 EC 8일 ECC 이런 식으로 쭉 기계열로 되어 있는 기계가 나오는 거죠.
근데 컴파일을 하면 기계가 나오는데 아까 한 번 중간 단계가 있었잖아요.
그래서 어셈블리어 코드가 나오고 이 어셈블리어 코드를 기계어로 변환하는 식으로 컴파일이 진행이 됩니다.
잠깐 복습하자면은 그래서 컴파일이 사실은 예전에는 요것까지만 하는 게 작은 의미의 컴파일이 있었는데 최근에는 그냥 요거 어샘플어도 나오고 기계화도 나오고 이런 걸 우리는 그냥 컴파일이라고 크게 범위를 넓혀서 컴파일 범위를 넓혀서 사용하고 있습니다.

1:00:24
다음에 링킹인데요. 목적 파일끼리 합쳐서 실행 파일을 만드는 과정입니다.
목적 파일은요. 그 기계화로 되어 있긴 하지만 이게 실행을 위한 부분이 빠져 있습니다.
그래서 예를 들어서 목적 파일이 이렇게 그러니까 헬로라는 CPB 파일이 있었다고 하죠.
CPB 파일이 있었다고 하면은 이 CPB 파일을 목적 파일로 바꾸면은 요렇게 돼 이렇게 되는데 그럼 이렇게 되고 자기 자신에 대한 요 어셈블리 기계는 다 갖고 있어요.
그렇지만 예를 들어서 아까 헬로 코드를 보면은 화면에 출력하기 위한 씨아웃 객체 그리고 이런 연산자들을 갖고 있어요.
그러면은 요거 자체는 c아웃이라는 요 객체는 내가 짠 코드가 아니라 불 표준 라이브러리에서 공급하는 거거든요.
그러니까 시불불 자체 환경에서 제공하는 객체입니다.
그러면은 내가 사용하는 내가 사용했던 요 씨아웃이라는 것도 여기다 붙이고 그리고 여기서 요 연산자도 사용했거든요.
c아웃

1:01:35
꺽꺽색 이런 식으로 작성했기 때문에 이것도 이제 여기다 붙이는 거죠.
그래서 완벽한 실행을 위한 모든 코드들이 기계들이 들어있는 파일 그래서 실행 파일입니다.
모든 필요한 게 들어있는 이 실행 파일을 만들어서 이거를 실행하면 됩니다.
이렇게 구분을 해보면요. 이렇게 현재 CPP 파일을 오브젝트 파일로 바꾸는 것을 우리는 컴파일이라고 하고요.
그다음에 이 오브젝트 파일과 그리고 이 오브젝트 파일에서 사용했던 외부 외부에 있는 오브젝트 파일일 수도 있고 라이브러리일 수도 있습니다.
그런 것들을 갖다가 이렇게 붙이는 거 빈드에다 붙이는 거 이런 것을 링킹이라고 합니다.
잠깐 잠깐 얘기했는데 중요한 거는 이렇게 갖다 다른 데도 갖다 붙이는 게 다른 오브젝트 헬로 오브젝트가 있고 인 오브젝트가 있다고 해볼까요? 인 오제이

1:02:34
다른 오브젝트에 있는 걸 이렇게 갖다가 갖고 올 수도 있습니다.
이렇게 다른 오브젝트에 있는 걸 갖고 올 수도 있고 또는 라이브러리에 들어있는 것을 이렇게 갖다가 붙일 수도 있어.
서로 오비제 파일끼리 이렇게 합칠 수도 있어. 그래서 이렇게 오브젝트 파일이나 라이브러리에 있는 걸 필요한 것을 갖다 붙여서 하나의 실행 파일을 만드는 것을 우리는 링킹이라고 한다.
이거 구분해야 됩니다. 컴파이어 링킹 그래서 우리는 비주얼 스튜디오 보면요.
컴파일만 따로 하고 링킹만 따로 할 수 있어요. 그렇지만 보통 여러분이 실행을 하면은 컴파일하고 링킹을 그냥 이어서 쭉 편집기가 같이 해 줍니다.

1:03:18
실행 파일은요 독립적으로 바로 실행 가능합니다.
그렇죠 아까 필요한 코드를 다 갖다 붙였잖아요. exe 파일 만들 때 그래서 바로 실행 가능하고요.
그럼 실행 중에 이제 링킹까지 끝났다는 것은 컴파일하고 링킹이 끝났다는 것은 그 점에서는 이제 오류가 안 났다는 거야.
그럼 실행 중에 발생하는 오류는요. 원하는 결과가 나오지 않거나 또 실행 중의 프로그램이 갑자기 퍽 하고 죽어버립니다.
땡 하고 뭐 소리가 나기도 하고 그냥 에러 코드가 나오면서 죽어버리죠.
이런 게 실행할 때 나는 에러인데요. 그럼 차라리 오히려 컴파일하고 링키 링크할 때 에러가 나는 것은 안내 메시지도 나오고 오히려 에러가 좀 간단한데 이제 실제로 exe 파일까지 만들었어.
근데 얘를 실행하다 오류가 나오잖아요. 실행하다 이거를 그러면 얘는 좀 어렵습니다.
왜냐하면 문법적으로나 링크적으로 이런 거 오류가 없거든요.
코드에 그렇지만

1:04:21
실행할 때 오류가 나는 거죠. 그래서 이런 것을 이런 오류를 찾기 위해서요.
디버깅을 수행을 해야 되는데 그래서 실행 중에 발생 오류를 찾는 과정이 요 디버깅이라고 하는데요.
이게 어렵습니다. 그냥 눈으로 코드를 아무리 봐도 몰라 그래서 어떻게 하냐면은 실행을 하면서 실행하는 중간중간 값을 계속 볼 수 있게 해줍니다.
그래서 이런 것들을 하게 해주는 게 디버거라고 하고요.
이게 디버깅을 도와주는 프로그램이고요. 컴파이를 만드는 회사에서 함께 공급합니다.
그래서 요 디버거를 가지고서 실제로 실행을 하면서 실행하는 중간에 예를 들어서 인트 a가 있었다 인트 a가 있었다 그러면은 실행하면서 요 a 값을 계속 이게 1이었고 이게 2로 변하고 3으로 변하고 이런 것들을 계속 찍어보는 겁니다.
그러다 보면 나는 이게 옷까지만 가야 되는데 갑자기 여기 20이 나왔어 그럼 여기서 뭔가 문제가 있었나 보다 하고 20 있는 데서

1:05:20
아

1:05:22
이제 이걸 힌트로 갖고 계속 찾아보면 되는 거죠. 아무튼 이런 식으로 해서 디버거를 사용을 하고 할 수가 있습니다.
그래서 또 이 디버그를 갖고 할 수 있는 기능이 소스 레벨 디버깅을 할 수가 있습니다.
CF 소스를 한 라인씩 실행하고 변수 값의 변화를 보면서 오류를 발견하면 되는 겁니다.
그래서 예를 들어서 소스가 있으면 9번째 줄, 10번째 줄 11번째 줄 있으면은 한 줄씩 한 줄씩 한 줄씩 실행을 하면서 아까 말한 이 변수 같은 걸 보는 거야 이런 거를 이제 디버깅 하게 해주는 거죠.
그래서 비주얼 스튜디오는요 소스 레벨 디버깅을 지원을 합니다.
그게 무슨 말이냐 소스 코드 한 장씩 한 줄씩 한 줄씩 가면서 디버깅하는 기능을 구현하고 있습니다.

1:06:15
아까 링크할 때 제가 잠깐 얘기를 했었는데 씨불 자체에서 제공하고 있는 객체나 함수나 이런 것들이 있다고 했습니다.
이런 걸 우리는 씨불불 표준 라이브러리라고 하고요.
이 라이브러리를 크게 3개 그룹으로 구분을 할 수 있습니다.
하나가 c 라이브러리 하나가 씨플풀 입출력 라이브러리 하나가 씨플플 STL 라이브러리입니다.
아니 c 라이브러리는요 이름에서 보듯이 기존 c 표준 라이브러리를 수용해서 CF 풀에서 사용할 수 있게 한 함수들입니다.
그러니까 c에서 있던 라이브러리들을 씨플용으로 변환해서 가져다 놓은 게 c 라이브러리고요.
다음에 씨플뿔 입출력 라이브러리인데요. 시플에서 화면을 보여준다든가 아니면 사용자의 입력을 받아들일 때 사용하는 함수나 객체가 있겠죠 그런 것들을 다 구현해 놓은 라이브러리 소스 코드 그거는 이제 컴파일에서 놔둔 거죠.
그래서 콘솔 및 파일 입출력 콘솔은 검정창 커멘드 창 콘솔 및 파일 입출력을 위한 라이브러리가 14 라이브러리고

1:07:28
CT풀 STL 라이브러리는요. 제너릭 프로그래밍 아까 말했죠.
변수를 나중에 읽게 하는 변수에 따라서 변수의 타입을 나중에 결정하게 해주는 그런 기능을 제너릭 프로그램을 지원하기 위한 템플릿 라이브러리를 이렇게 지원하고 있습니다.
보면은 여기서 요 좀 색으로 표현을 했는데요. 이런 거 이런 거 입출력 시플플 입출력 이런 거 그리고 STL 라이브러리 이렇게 하고 있습니다.
그리고 뭐 좀 특이한 게 있다면은

1:08:07
네 요거 있죠 요거 뉴 그래서 요 뉴 헤더 파일은 STL에 포함되지 않는 기타 아까 3개로 구분되지 않는 그런 나머지 것들은 이 류에 들어가 있습니다.
그럼 지금까지 했던 것을 한번 그림으로 한번 단계를 따라가 보도록 하겠습니다.
일단은 여러분들이 이런 텍스트죠. 텍스트를 이용해서 이런 소스 파일을 작성해 그럼 여러분들이 컴파일을 해 그러면 오비제 파일이 나옵니다.
오비제이 파일이 나오고 이 안에는 기계화가 들어가 있죠 그럼 기계어긴 하지만 여기 이 기계어들이 사용하고 있는 함수나 객체가 없다고 했죠.
그러면 외부에서 라이브러리 또는 다른 OBJ 파일에서 그 부분을 빌려옵니다.
그래서 그 부분을 이어 그래서 링킹하면은 실제 실행 파일이 나옵니다.
그러면은 이거는 이제 완전히 실행할 수 있는 파일이에요.
그럼 이거를 이제 실행해. 그럼 잘 되면은 좋아 그럼 헬로우 하고 끝 그러면 이제 실행 끝 그렇지만 오류가 발생하면 여러분들 이제 디버깅해야죠.
디버깅에서 오류를 수정하고

1:09:13
그럼 여러분 수정할 때 여러분 어디야 여러분이 수정하는 것은 아마 이 소스 파일을 수정을 하겠죠.
그럼 다시 한 번 컴파일을 하고 목적 파일 만들고 링킹하고 실행 파일 만들고 실행 또 되면은 좋고 안 되면 다시 오류 오류가 나면 다시 디버깅 이렇게 이제 계속계속 돌다가 마지막으로 최종적으로 실행이 정상적으로 끝나면은 정상적으로 끝나면은 이제 프로그램 개발이 마무리되는 거죠.
사실 실행이 되면은 보통은 어떻게 합니까? 이제 코드 최적합니다.
지금까지는 그냥 빨리 이렇게 실행이 되는지를 검증했고요.
이제 검증이 되면 이렇게 하는 게 정상적으로 동작을 하는구나를 알게 되면은 이제 전체 이 짜놓은 코드를 보고 이제 분석을 하겠죠.
여기 너무 비효율적으로 짰네. 좀 바꿔보고 바꿔보고 바꿔보고 해서 이제 실행하면서 이제 시간도 재보고 메모리 사용량도 재보고 하면서 최적화하는 그런 과정이 이제 후 처리가 더 남아 있습니다.

1:10:10
이렇게 해서 이론은 했고요. 다음은 비주얼 스튜디오를 갖고서 간단히 이제 프로젝트 만드는 걸 할 텐데요.
이거는 실습을 위해서 남겨두기로 하고요. 여러분들 이제 이거 하기 전에 여러분들이 할 거는 구글이나 아무 데나 가서 ms 가서 비주얼 스튜디오 다운로드를 검색하세요.
다운로드 검색하면은 다운로드 검색하면은 이제 링크 나올 겁니다.
다운로드 검색하면은 이제 여러 버전이 있을 거야.
그러면 여러분들은 최신 지금은 22년도 게 최신인데 22년도 거의 커뮤니티 버전입니다.
커뮤니티 커뮤니티 커뮤니티 t 버전을 다운받으면 됩니다.
그럼 이게 무료고요. 우리는 더 이상 더 좋은 기능이 필요 없습니다.
커뮤니티 버전 다운 받아서 설치까지만 해놓으면 됩니다.
그럼 설치까지 하고 우리 실습 시간에 그 뒤에 내용을 갖고 같이 실습 진행하도록 하겠습니다.
