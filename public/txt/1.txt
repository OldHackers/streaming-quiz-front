ryu
2023.12.15 금 오후 3:34 ・ 79분 37초
장선규


00:00
안녕하십니까? 여러분 운영체제 수업 시간을 이어서 이어서 이제 싱크로나이제이션과 데드락 어버이던스를 설명하도록 하겠습니다.
6장이고요. 우리가 그동안 이제 중간고사 대체 텀 프로젝트에 대한 설명이라든지 인바이트톡이 있었기 때문에 지난 5장 끝낸 스케줄링 한 부분 물론 맨 뒷부분은 별로 중요하지 않아서 일부 스킵했습니다만 그 이후로 좀 오랜만입니다.
제가 개인적으로

00:35
음

00:37
좀 병원에 있어야 될 일이 있어가지고

00:41
그

00:43
이 강의 영상이 늦게 올라가게 됐습니다. 굉장히 여러분께 좀 미안하고요.
남은 기간에는 그런 일 없도록 좀 제때 준비를 해서 업로드 하도록 하겠습니다.
여러분 그 오퍼레이팅 시스템에서 싱크로나이제이션 여기 뭐야 싱크로나이제이션과 데드락 어버이던스가 나오는데 이건 우리나라 말로 하면은 동기화 동기화를 맞춰주는 거고 데드락 어버이던스는 데드락은 그냥 데드락이라고 하죠 또는 뭐 병목 현상 이런 거 얘기하는데 그런 데드락을 병목 현상을 어버이던스 그러니까 어버이던스 회피하는 그런 방법들에 대해서 이야기하도록 하겠습니다.
일단 전체적으로 우리가 그랜스 한번 잠깐 한번 비유를 그랜스 보면은 전체적으로 싱크를 위한 용어 정리를 먼저 한번 해보겠습니다.
그 동기화 동기화 아까 전에 싱크로나이제이션 그런 얘기죠.
개념적으로 보면 한정적인 자원 자 우리 리소스가 한정적일 때 여러 트레이드들이 프로세스든 트레이드들이 동시에

02:01
이 리소스를 가지고 뭔가를 하려고 그럴 때 메모리 억세스를 한다든지 여러 가지 CPU를 점유하려고 한다든지 그럴 때 모두가 동시에 접근을 하면은 결과적으로 선택을 해야 되죠.
니가 먼저 할래 내가 먼저 할래 네가 먼저 할래 그런 문제가 있고 서로 간에 잘못하면은 다른 프로세스나 트레이드가 데이터를 쓰고 있는 과정에서 다른 프로세스나 트레이드가 접근을 해서 데이터를 건들기 시작하면 문제가 되겠죠.
제가 요 종이 노트에 3 더하기 3은 5 하려고 딱 6이죠.
6을 딱 쓰려고 그랬는데 누가 옆에서 o라고 이 위치에다가 메모리 데이터를 써버렸어요.
문제가 되겠죠 그런 것처럼 하나의 프로세스가 하나의 리소스를 먹고 뭔가를 하려고 그럴 때 다른 애가 들어와서 이런 식으로 방해를 하면 문제가 될 수 있기 때문에 동시 접근 문제를 차단하는 그런 이슈들이 있습니다.
그래서 트레이드들에게 하나의 자원에 대한 처리 권한을 주거나

03:10
순서를 조정해주는 그런 뭔가 동기화 이슈가 있습니다.
동기화라는 건 그러니까 결국은 오더를 만들어주는 그런 과정에 해당하겠습니다.
그리고 레이스 컨디션 레이스 컨디션은 레이스 달리는 거죠.
우리 소위 포커 칠 때도 레이스 이런 죄송합니다. 레이스는 올리는 거구나.
갑자기 레이스를 보는 순간 그런다고 제가 도박을 하거나 그러지는 않습니다.
근데 갑자기 갑자기 레이스 컨디션 그 레이스랑 역시 한국 발음 때문에 잠깐 헷갈렸습니다.
그 레이스는 베팅 금액을 올리는 레이스고요. 이건 레이스 컨디션 달리는 거죠.
그러니까 프로세스 간의 자원을 사용하려고 서로 경쟁 경쟁입니다.
이거는 이제 문제가 발생할 여지가

04:09
어

04:10
좀 있습니다. 왜냐 하나의 프로세스가 동시에 이 자원을 쓰려고 서로 막 접근을 하다 보면 아까처럼 문제가 나는데 가장 큰 이유가 얘가 한 번 하고 좀 있다가 얘가 한 번 하고 또 좀 있다가 얘가 한 번 하고 그러면 이게 별로 문제가 안 돼요.
근데 서로 간에 미친 듯이 막 얘가 달려들고 얘가 달려들고 얘가 달려들다 보면 막 엄청나게 막 빈번하게 서로 경쟁하듯이 막 뛰는 거죠.
그런 상황이 되면 문제가 생길 여지가 있습니다. 왜냐하면 동시 또는 거의 하나가 마치 하나의 점유가 끝나기 전에 다른 녀석이 중간에 인터럽트 걸고 들어와서 뭔가를 훼방놓을 가능성이 있기 때문에 네 그거를 배제할 수 없기 때문에 문제가 됩니다.
그런 거를 우리가 레이스 컨디션이라고 하니까 이 용어도 알아두십시오.
임계 구역 우리나라 말로 임계 구역이라는 것은 크리티컬 섹션 컴퓨롤 사이언스가 아니라 CS라고 크리티컬 섹션이라고 합니다.

05:15
CSCS라고 얘기를 많이 하는데 크리티컬 섹션은 크리티컬하다 뭔가 이렇게 되게 좀 여기 임계로 번역했지만 크리티컬하다 이런 얘기 있죠.
우리나라 말로 뭐라고 번역해야 될까 아주 중요한 특징적인 그런 거 근데 이제 그런 영역 중요한 영역이다.
그래서 공유 자원에 접근하는 프로세스 내부의 코드 영역 즉 한 프로세스가 이 영역을 수행 중일 때 다른 프로세스가 같은 영역을 수행한다면 문제가 발생한다.
무슨 일이 있냐면 우리가 코드가 이렇게 프로그램 코드가 쭉 있어요.
근데 내가 어느 부분은 코드상의 어느 부분 이만큼은 절대로 내가 이거를 업데이트하는 동안 남들이 이거 들어와서 이 데이터를 여기 있는 변수에 대한 데이터나 메모리나 뭔가를 건들면 안 되는 거예요.
그럴 때는 이거는 아무도 건드려서는 안 돼. 지금부터는 할 때 여기다 크리티컬 섹션이라고 부르는 거예요.
이 영역은 아주 중요한 영역이니까 그래서 이 영역과 이 영역 사이에는

06:18
적어도 이 동안은 내가 독점적으로 이 리소스를 사용할 수 있게끔 내버려둬라는 게 크리티컬 섹션입니다.
다른 데서는 뭐 다른 데는 테스크 스위칭이 일어나니까 프로세스가 돌다가 얘가 돌 수 있고 얘가 돌 수 있고 그러면서 이해를 하는데 이 구간만은 적어도 이 리소스에 대한 권한을 인정해줘라고 하는 거죠.
그게 중요한 구간이라 해서 임계 구역 뮤추얼 익스클루존 뮤추얼하다 상호 뮤추얼 펀드 할 때처럼 뮤추얼 상호적인 얘기죠.
상호 그리고 익스클루지 배제한다는 거예요. 인클루즈 익스클루 아시잖아요 그럼 상호 배제 서로 간에 배제한다.
이거 뭐냐 서로 간에 그 쪽 나는 경우 소위 당구 치는 사람들은 알죠.
쫑나는 경우 그 얘기를 하는 겁니다. 저는 당구를 칠 줄 몰라서 포켓볼 몇 번 쳐본 게 전부라 못하는데 이 뮤츠 익스크루존이 곧 쫑 나는 경우 이제 피하자는 얘기고요.
그래서 한 프로세스가 공유 자원을 접근하는 CS 크리티컬 섹션 영역을 수행 중이며 다른 프로세스들은

07:25
그 CS 영역 코드를 수행할 수 없다. 그러니까 내가 하고 있으면 야 좀 제발 다른 애들은 하지 마 그 얘기예요.
이거를 서로 간에 그러면 뮤추얼하게 그런 합의가 돼 있어야 되죠.
그렇죠. 그래서 서로 상호 배제를 하자 이거예요.
내가 쓸 때 너희들 내가 만약에 다른 데 쓸 때는 너네들이 해도 돼 그렇지만 내가 CS 요 영역 이 영역을 할 동안은 제발 너네들은 거기 접근하지 마 자원에 접근하지 마 이런 얘기입니다.
방 안에서 내가 아무 데나 돌아다닐 때는 니네들이 와서 뭐 이래저래 하고 해도 괜찮은데 내가 화장실에 들어갔을 때만큼은 같은 방에 들어오지 마 이거랑 같은 얘기죠.
그래서 뮤텍스라고 뮤추얼 뮤추얼 익스클루존 그래서 뮤추얼의 뮤트를 빼고요.
뮤트 그다음에 익스클루존의 이 x를 떼서 붙이면 뮤 텍스가 됩니다.
이 단어를 기억해 두세요. 뮤 텍스

08:31
응

08:33
일종의 럭킹 기법입니다. 그래서 화장실 열쇠를 가지고 있는 사람이 화장실에 들어가서 이 톤 아이 클라우드 아이 클라우드에 안 해 화장실 열쇠를 가지고 있는 사람이 화장실에 들어가서 문을 잠가버리는 거예요.
그다음에 그 사람이 나와야지만 그다음 사람이 들어가는 거 이건 뮤텍스라고 보시면 됩니다.
그런 개념이고요. 세마포어는 이제 세마포어는 뮤텍스를 구현하는 것도 한 가지 방법 중에 하나라고 보시면 되는데 관련된 겁니다.
비슷하죠. 동시에 어떤 리소스에 만약에 몇 개 이상의 프로세스나 이런 프로세스가 접근이 가능하다 하면은 몇 개까지가 접근이 가능한지의 개수가 정해져 있을 겁니다.
CPU 코어가 몇 개 있으니까 몇 개까지는 우리가 CPU 자원에 접근이 가능하다 이런 것처럼 그런 식의 예제로 봤을 때 그 카운터를 두고요.
그 카운터까지는 허용을 해요. 그 카운터가 아직 안 찼을 때까지는 한 예로 방에 의자가 5개라면

09:45
네 5개면 5개까지는 사람이 앉을 수 있으니까 이 방에 들어간다.
오케이 들어와 오케이 들어와 커 커 커밍 할 수 있는데 이 다섯 자리가 다쳤어요.
누군가 들어오려고 그러면 더 이상 안 돼 우리는 이제 풀이야.
더 이상 안 돼. 문 밖에서 기다려줘. 누군가 나갈 때까지 그게 일종의 세마포어입니다.
그래서 세마포어에서는 카운터를 두고요. 카운터 카운터를 두고 넘버를 허용하는 넘버를 세야 됩니다.
그러니까 당연히 주어진 숫자는 물론 옵션으로 주어지는 거고요.
5개 7개 3개 그럴 수 있는 거죠. 모니터 기법은 자바는 이제 가졌다는데 시에서는 지원을 안 하는 기법이고 교재는 좀 설명이 나와 있습니다.
하지만 스킵하죠. 모니터 같은 걸 좀 공부하는 사람들도 있지만 저는 시에서 지원 안 하면 의미가 크게 없다고 보기 때문에 스킵 하셔도 되겠습니다.
그림으로 이제 한번 이해해보는 시간을 갖도록 하겠습니다.
세마포 세마포는 아까 말했지만 카운터를 좀 두는 개념이라고 그랬죠.

10:53
그래서 쉐어드 리소스가 만약에 여기 1, 2 3, 4, 5, 0부터 6개가 우리가 s워드 영역이 딱 있어요.
그러면 이렇게 연소기의 자리가 있는 거죠. 트레이드들이 여기도 있고 여기도 있고 여기도 있고 여기도 있고 얘네들이 서로 가서 LS reles wit relis는 그냥 점유하고 나오고 점유하고 나오고를 한다고 생각하시면 됩니다.
이렇게 서로 할 수 있다는 거예요. 그런데 만약에 점유하는 애들이 어느 순간에 0 1 2 3 하다가 이 모두를 다 점유했다.
근데 다른 프로세스가 또 들어오려고 한다 그러면 걔는 못 들어오는 겁니다.
그런 개념으로 보시면 되고요. 뮤텍스는 그냥 하나에 넣고 we 릴리스를 반복하는 겁니다.
뮤텍스는 자원이 하나 s어드 리소스가 1개라고 생각하시면 됩니다.
같은 개념이죠. 같은 개념인데 넘버가 여러 개 올 수 있는 건 세마포어고요.
아닌 건 유텍스입니다. 세마포어로 구현하는 게 안전한 순간이 있어요.
왜냐면 실제로

12:12
세마4는 숫자 카운터를 늘릴 수 있기 때문에 0 1 1 이런 식으로 측정해서 테스트를 할 수 있고 텍스 그러니까 뮤텍스가 더 간단한 것도 있지만 그 리소스가 하나가 아닌 멀티플 한 경우에는 세마포를 쓸 수밖에 없어요.
네 그런 게 있습니다. 특히 버퍼 관리하면서 버퍼에다 대고 데이터를 쓰는데 지금 제가 어떤 버퍼에다가 크게 패킷 같은 거를 집어넣을 수 있는 게 공간이 한 10개 있다.
이 10개를 찰 때까지는 뭔가 이런 거 할 때는 세마포를 쓸 여지가 있습니다.
그림 출처는 6이고요. 제가 이제 기존 슬라이드 가지고는 좀 부족한 부분이 있어서 이런 부분을 조금 제가 추가한 겁니다.
백그라운드 y 싱크가 필요한지 그러니까 싱크가 왜 필요한지죠? 일단 제가 여기 한번 예제를 들겠습니다.
카운터 예제인데 문장을 다 읽어보면 조금 시간이 걸리는데 하나만 좀 얘기할게요.
프로세스들은 익스큐트 컨커런트리 콘 동시에 커런트리

13:20
그러니까 동시에 익스큐트가 될 수 있고 그러면 메이비 인터럭티드 애니 타입 언제든지 인터럭드 당할 수 있고요.
파셔리 컴플레이링 익스큐션 파셔링 부분적으로 익스큐션이 컴플리딩 됐다는 얘기는 아직까지 이게 다 끝나지 않았는데 갑자기 중간에 인터럽트가 걸리는 거예요.
그래서 나는 어느 리소스의 메모리에다가 데이터를 쓰고 있었는데 갑자기 인터럭터가 걸려서 다른 프로세스가 들어와서 그 자원을 차지한 다음에 그 자원화 되고 데이터를 업데이트를 해버리면 문제가 될 수 있습니다.
그런 경우 그러니까 싱크로나이제이션이 필요하다는 거죠.
그리고 CCRT 억세스 동시에 억세스하는 것 2 쇼드 데이터에 하는 것은 메인 리졸 결과를 가져온다.
데이터 인컨시스턴시 데이터가 컨시스턴시를 읽는 그러니까 우리나라 말로 컨시스턴시를 뭐라고 해야 될지 모르겠는데 영속성 컨시선스 그런 표현이죠.
한국말로는 좀 애매한데

14:24
컨시스턴스를 유지할 수가 없다는 거예요. 그러니까 이제 여러 s워드 데이터의 프로세스들이 와서 얘가 건들고 쟤가 건들고 하다 보면 데이터가 변질돼 잘못돼버리는 거죠.
그리고 메인 테이 그럼 데이터 컨시스턴시는 컨시스턴시를 유지하려고 하면 리쿼이어 요구한다.
무엇을 어떤 메커니즘을 인슈 odl 익스큐션 순차적으로 수행이 돼야 된다는 거예요.
커퍼레이링 프로세스들 간에 odl 익스큐션이 돼야 된다.
즉 이번에는 1번 프로세스, 2번에는 2번 다음에는 5번 프로세스 그다음에 3번 프로세스 이런 순차적으로 어떤 들어와야 될 이런 것들이 오더가 있어야 된다 그 얘기입니다.
그 문제를 한번 일러스트레이션을 한번 해보겠습니다.
어떤 문제가 있는지 카운터를 두고 처음엔 셋 제로로 해놔요.
0으로 해놓고 하나는 인크리멘트 되고 하나는 디크리멘트 되게 해놓습니다.
네

15:23
그러니까 하나는 우리는 프로듀서 프로세스라고 하고요.
하나는 컨슈머 프로세스라고 합니다. 프로듀서는 생산 그러니까 인클리먼트하다.
즉 0에서 플러스 1 플러스 2 이런 식으로 증가시키고요.
컨슈머는 깎아 먹는 거예요. 소비하는 거니까 값이 있으면 어떤 값이 만약에 카운터라는 값이 5다 그러면 여기서 빼기 1을 해줘서 4 3 2 1 이런 식으로 계속 빼먹는 하나는 증가시키고 하나는 빼먹는 그런 과정을 생각하시면 되겠습니다.
그래서 예제 코드를 하나 말씀드릴게요. 프로듀서 와일 2 와일 2루 처음부터 너무 강력하죠.
그냥 무조건 수행해 와일 언제 동안 또 하냐면 카운터가 버퍼 사이즈와 같다면은 버퍼 사이즈가 예를 들면 제가 몇 백 바이트 또는 몇 백 킬로바이트 뭐 이렇게 줄 수 있죠.
퍼퍼 사이즈는 여기서 주어진 어떤 특정한 값이라고 가정하고요.
보통 시어어에선 그런 거 대문자로 써가지고 샵 디파인으로 맨 코드 맨 위에다가 디파인 하고서는 이런 거

16:35
이거 써주고 뭐 예를 들면 1500 이런 거 써주고 그렇죠 어쨌든 버퍼 사이즈와 카운터가 같다면 너 아무것도 안 합니다.
그러다가 두어딘이고요. 버퍼가 아이고 이걸로 갈까 버퍼가 들어오는데 인 넥스트 프로듀스드 넥스트 프로듀스 다음번에는 버퍼의 그러니까 이는 계속 지표죠.
인덱스죠. 이건 인덱스 넘버고요. 그 버퍼에다가 이게 들어가가지고 값이 들어가는 거예요.
다음에 생산되는 거는 이 버퍼의 값으로 들어가는 거죠.
네 그러고 e은 인 플러스 1 나누기 버퍼 사이즈 이거 저거네 1 2 3 이런 식으로 막 4 이렇게 두고서는 이게 만약에 버퍼 사이즈가 4다 그러면은 버퍼 사이즈가 이거 지금 4개죠.
그러면 이거 좀 작은 펜으로 하겠습니다.

17:58
4개죠. 1 2 3 4 그러면은 버퍼 사이즈보다 1이 큰 큰 거 그즉 5 5에다가 이게 0부터 시작하니까 그럴 수 있겠구나 이거는 이제 저걸로 보면 0이죠.
이거는 0 이거는 1 이거는 2 이거는 3 그래가면서 뭔 짓을 하냐면 거기다 1을 더해서 퍼센트를 해줍니다.
퍼센트 모드 값으로 나눈 거죠. 그럼 나머지가 나머지가 0이면 여기에다 데이터를 뭔가 쓰고요.
나머지가 1이면 여기다 쓰고 2면 여기다 쓰고 3이면 여기다 쓰고 그다음에 하나 더 증가하면 어떻게 되죠? 나머지가 다시 4가 되면 0이니까 다시 여기다 쓰고 1이면 여기다 쓰고 그래서 계속 데이터를 이렇게 쓰고 이렇게 쓰고 이렇게 쓰고 계속 번갈아가면서 이렇게 이렇게 번갈아가면서 쓰게 돼 있습니다.
그렇게 하고 그때 이제 카운터를 뿔뿔 해주는 겁니다.
이 때 카운터를 뿔뿔 해준다는 건데 그래서 값을 쓰고요.
컨슈머는 이제 끝으로 이거 좀 괜 버퍼에서 아웃 값이 있다고 치고요.

19:27
넥스트 컨시드가 이제 나오는 거고 이것도 역시 사이즈에다가 이렇게 해서 모드 값 치워서 아웃 값 얻고 카운터를 하나씩 빼준다.
이게 조금 여러분들이 이렇게만 보면은 조금 설명을 보면은 좀 헷갈릴 수 있는데 그냥 여러분 제가 조금 쉽게 설명을 드리자면 하나는 지금 카운터를 플러스 플러스를 하고 있고요.
버퍼를 관리하면서 하나는 마이너스 마이너스를 하고 있습니다.
관리하는 과정에서 여기 사실 왜냐하면 중간에 카운터 값들이 막 나오지 않아서 그렇습니다.
그러다가 카운터 가이턴 0이면 누구나 아무것도 안 해요.
그리고 카운터가 여기는 풀이 나면은 카운터가 그러니까 버퍼 사이즈와 똑같아지면은 역시 안 해요.
그러니까 얘는 무슨 말이냐면 한쪽에서는 그러니까 이거 여러 번 이거 못 쓰겠네요.
풀이 나면 아무것도 안 하니까 한 번 쓰고 나면 끝이네.
얘는 데이터를 계속 이렇게 쓰고 있어요. 한쪽은 프로듀서는 얘는 데이터를 자꾸 뽑아서 빼는 거예요.
일로

20:35
그래서 일로 쭉 빼고 있고 얘는 쓰고 있고 그러다 보니까 다 찼으면은 더 이상 쓰지는 못해요.
뺄 수만 있어요. 빼는 애들은 나중에 비웠으면 버퍼가 비었으면 더 이상 못 비우고 살 때까지 기다립니다.
그러니까 버퍼를 쓰는 것, 버퍼에다 데이터를 쌓는 거, 버퍼에 있는 데이터를 빼내는 거 이렇게 두 가지가 프로듀스와 cosm로서 동작한다는 겁니다.
그래서 여러분이 나중에 인터넷 이용한 어떤 통신 프로그램 네트워크 프로그램을 하거나 이런 걸 했을 때 버퍼 컨트롤 해야 된다라고 하면 여러 가지 버퍼 쓰는 방법이 있습니다.
메모리 얼로케이션을 쓰는 것도 기법이 있는데 이런 식의 배열을 이용한 버퍼를 쓴다.
왜냐면 퍼퍼가 예를 들면 1바이트짜리 언사인드 언사인드 캐릭터를 가지고 버퍼를 만들어서 몇 바이트를 쓴다.
이런 비디오에서는 그 픽셀 단위가 언사인드 캐릭터이기 때문에 이렇게 할 수 있는데 이런 거를 한다고 그럴 때

21:48
한쪽에서는 데이터를 쓰고 한쪽에서는 데이터를 잃고 그러다 보니까 그런 걸 어떻게 구현해야 되지 할 때는 이런 식의 코드가 제일 좋습니다.
데이터가 비었으면 아무것도 안 하고 기다리고 데이터가 다쳤으면 아무것도 안 하고 기다리고 그 외에는 한 놈은 더 해주고 한 놈은 빼준다.
즉 데이터를 쌓는 거 데이터를 잃어버리는 거 이렇게 해주면 코드가 깔끔합니다.
이런 식으로 우리가 보통 코드를 한다는 거예요. 근데 이제 레이스 컨디션이 발생하면 좀 이슈가 생긴다 이겁니다.
한쪽에서는 카운터 뿔뿔을 해주고요.

22:23
이게 이 코드 자체만으로 보면은 이거는 뭐 그럴싸한 코드예요.
이렇게 동작할 수 있겠구나 오케이 근데 문제는 이게 이제 레이스 컨디션에 들어가면 중간에 우리가 컴파일이 돼서 기계어로 변하고 그것들이 중간에 테스크 스위칭이 일어날 때 이런 걸 고민을 해봐야 되는데 문제가 됩니다.
이거는 카운터플은 QDB 인플멘티드 레지스터에다가 카운터 값을 집어넣습니다.
al케이트 하는 거죠. 할당하는 거죠. 그다음에 레지스터 1에 있는 값을 다가 카운터 뿔뿔이니까 하나를 더해줍니다.
카운터 불은 이거잖아요. 원래 카운터 뿔뿔은 카운터는 카운터 플러스 1이죠.
그렇죠 그러니까 카운터에다 1을 더한 다음에 그걸 다시 카운터에다 집어넣는 개념이 되겠습니다.
그러다 보니까 레지스터에다가 1을 더해서 그거를 레지스터에 할당을 합니다.
왜냐하면 카운터가 처음에 모르니까 이게 여기 들어가고요.
그다음에 여기 해서 여기다 들어갑니다. 그다음에 레지스터 1의 값을 카운터로 업데이트를 해주는 겁니다.

23:31
그래서 카운터 뿔뿔이 일어나는 건데 이제 어셈블리 같은 거 생각하시면 됩니다.
카운터 마이너스 마이너스는 카운터 값을 카운터 레지스 그러니까 2에다 만들어 1 아니어도 돼요.
레지스터 2에다 넣고 레지스터 2 값에서 현재 1 1을 빼주고 그러니까 현재 레지스터 2에서 1을 빼서 다시 레지스터 2에 넣고 이거를 카운터에서 대입을 해줍니다.
그러면은 카운터가 하나 빠집니다. 교수님 왜 카운터 가지고 직접 카운터는 카운터 플러스 1 카운터는 카운터 마이너스 1을 안 해줍니까? 그게 어셈블리 레벨에서는 일단 숫자 같은 것들을 변수를 레지스터에다 넣고 더하고 빼고 곱하고 나누기를 하기 때문에 그 이슈가 있고요.
그렇게 해서 중간에 템프 디렉토리 템프 베어리업을 두듯이 동작을 합니다.
근데 이럴 때 문제가 뭐냐면 CPU 프로세스가

24:32
요거랑 요거가 레이스 서로 경쟁을 하다가 하나가 다 끝나고 하나가 하고 하나가 다 끝나면 하나가 하고 이러지 않고 얘가 되다 중간에 테스크 스위칭 중간에 일어나고 얘가 끼어들거나 얘가 수행되다가 중간에 테스크 스위칭이 일어나고 얘가 뛰어들게 되면 문제가 발생합니다.
볼까요? 어떻게 되느냐 보십시다. 컨sd dis 익스큐션 인터레빙 위드 카운터 카운터 이니셜 처음에는 5에서 시작을 합니다.
그래서 시퀀셜리 0번 1번, 2번 3번, 4번 5번으로 쭉 시퀀스가 진행될 때 처음에 프로듀서 프로세스가 두 번 수행이 됩니다.
레지스터는 카운터 레지스터는 레지스터 플러스 1 이 두 개가 수행이 됩니다.
그러면 카운터는 5였죠 그럼 레지스터 1은 5가 되고요.
레지스터 1 5에다가 1을 더하니까 이거 6이 되죠.
그러니까 어떻게 되죠? 레지스터 1은 이제 나오고 6이 됩니다.
레지스터 1은 이때 현재 6이 된 상태예요. 근데 갑자기 이때

25:40
테스크 스위칭이 일어나거나 하면서 레이스 컨디션이 일어나서 서로 막 달리는 그 상황 속에서 막 엄청 경쟁하다가 컨슈머 프로세스가 이제 수행이 되는 겁니다.
얘는 여기가 수행되는 거죠. 한 2개 정도 수행이 됐다고 가정을 합시다.
이거 가정이에요. 요쯤에서 바뀌었다 이거예요.
그럼 카운터 레지스터 2에다가 카운터 값을 집어넣고요.
아직까지 카운터는 o였죠. 그러면 이거는 카운터는 o니까 레지스터 2는 o입니다.
그렇죠 o죠. 그다음에 레지스터 2는 레지스터 2 마이너스 1 그럼 레지스터 2가 5니까 5에서 1을 뺀 4가 할당이 돼서 레지스터 2는 4가 됩니다.
요까지는 상식적으로 OK예요. 근데 이때 갑자기 이제 또 스위칭이 일어났다고 가정하고 프로듀서가 또 수행이 돼요.
이게 어떻게 보자면 이렇게 되는 거야 두 개 하다가 두 개 하고 그다음에 하나 하고 하나 하는 이런 상황.
그럼 프로듀스가 되면 아까 전에 마지막

26:44
마지막 문장인 카운터는 카운터 레지스터 1 이거를 해주는 거예요.
아까 레지스터 1의 값이 얼마였냐 여기 레지스터 1이 여기 6이라고 돼 있죠.
그러니까 카운터에는 6이 들어갑니다. 그래서 카운터는 6이 돼요.
근데 그다음에 다시 컨슈머가 수행될 때 카운터는 레지스터 2가 이게 오는 거죠.
이게 그럼 레지스터 2는 아까 얼마라고 그랬냐면 4였어요.
4 마지막에 그러면 4가 여기 들어가서 레지스 카운터는 4가 됩니다.
즉 원하는 결과가 안 돼요. 원래 얘는 얘는 자기가 수행됐을 때 5에서 시작했으면 6이 돼 있기를 바랐는데 얘는 엉뚱하게도 4가 돼버리고 중간에 이렇게 하면서 서로 간에 값들이 막 다르게 나오는 문제가 생기는 거예요.
한쪽은 카운터를 6으로 만들다가 한쪽에서는 카운터를 4로 만들어야 되는 이런 문제가 생기는 거죠.
그러니까 레이스 컨디션에서 특히 중간에 이게 이렇게 스위칭이 일어나면 좀 문제가 됩니다.
사실 이거보다 더 아주 적절한 예제가 있는데

27:52
어셈블리를 여러분들이 좀 잘 알아야 돼 가지고 그거는 제가 이걸로 대체하겠습니다.
요거 예제도 충분히 여러분들 입장에서는 이해가 가는 예제일 겁니다.
크리티컬 섹션 프라브로 아까 말했죠. 크리티컬 섹션은 함부로 들어가면 안 되고 정해진 그 어떤 영역이기 때문에 한 번에 하나의 어떤 프로세스가 수행이 되어야 한다.

28:19
네 그렇습니다. cost 시스템 ov n 프로세스 만약에 NG의 프로세스가 있다고 가정합시다.
p 제로부터 pn 마이너스 1까지 0부터 시작이니까 n 마이너스 1까지 해서 총 n개의 프로세스가 있다고 하고요.
각각의 프로세스는 크리티컬 섹션을 가지고 있습니다.
세그먼트 오브 코드, 세그먼트 오브 코드는 코드가 이렇게 프로그램들이 이렇게 쭉 있는데 그중에서 어떤 크리티컬 섹션 여기는 절대로 나 혼자 수행되어야 돼 하는 CS가 있다고 가정하고요.
프로세스는 메이비 체인징 커먼 베어리어블 업데이링 테이블 와이링 파일 이런 어떤 리소스에 공통의 리소스에 접근해서 뭔가를 한다는 거예요.
어떤 베어리어블 변수를 갖다가 체인징 바꾸거나 템프값 바꾸듯이 또는 어떤 테이블을 업데이트를 하거나 라 파일 리소스를 쓰거나 이런 짓을 하고 1 프로세스 인크리티컬 섹션 하나의 프로세스가 크리티컬 섹션 안에 들어가 있으면 메이비 스크리티컬 섹션입니다.
다른 녀석들은 그것을 건들지 못한다. 근데 이거를 여러분

29:39
이렇게 보시면 좀 개념적으로 약간 편합니다. CS가 있다고 이걸 하나의 방 공간으로 화장실 같은 거 생각하시고요.
다른 프로세스가 여기 들어와서 뭔가를 할 때는 다른 놈은 여기를 들어갈 수 없다 이렇게 생각하시면 됩니다.
그 비행기 화장실 생각하시면 되죠. 한 사람이 들어가서 베이컨트 돼 있던 거를 아큐파이드 이렇게 바꿔놓으면은 다른 사람이 못 들어가는 그런 식으로 생각하시면 됩니다.
물론 현실적으로야 주위 사람이 막 밀고 밀어붙여가지고 두 사람이 들어갈 수도 있죠.
근데 그런 경우를 만들면 안 된다는 거죠. 그래서 크리티컬 섹션 프라브럼은 이스트 디자인 프로토콜 s 이거를 되게 잘 할 수 있도록 디자인을 잘해야 돼요.
그 프로토콜을 내가 화장실에 들어가면 손을 다 씻고 나서 예를 들면 뭐 소변을 보고 할 때쯤에 안에 사람 있습니다 하고 그 바깥에 왜 아큐파이드로 바꾸는 거 비행기에서 그거를 하는 게 아니라 들어가자마자 제일 먼저

30:44
그거를 바꿔서 팻말을 바꿔서 아키 파이드로 바꿔놓고 그다음에 손을 씻고 뭘 하고 이런 식으로 해라고 서로 프로토콜을 정해야지 그러지 않으면 안에 사람이 비행기에서 화장실에 들어가서 자기는 거울을 보고 뭐 이렇게 거기 뭐 세수도 하고 손도 씻고 이러고 있는데 뒤에 사람은 아직까지 베이컨트롤 돼 있는 팻말을 보고 들어올 수 있죠.
그러면 어라 이러면서 거기서 아주 충돌이 일어나는 거죠.
그러니까 그런 프로토콜을 잘 정해야 된다는 겁니다.
그리고 이치 프로세스들은 머스크 에스크 이거 어떻게 보자면 머스크가 생각나네.
오늘 이번에 인간을 태워서 갔다 우주에 보내는 거 했죠 스페이스 엑스가

31:34
근데 제가 옛날에 미국에 있을 때 그 머스크가 그거 스페이스 엑스 세워서 막 그거 하는 거 보고 저도 그거 되게 멋있어 보여가지고 거기 취업하고 싶다는 생각을 한 적이 있었는데 제 분야는 뽑지 않더라고요.
그 당시에는요. 그리고 eh 프로세스는 머트 에스크 퍼미션을 꼭 물어봐야 됩니다.
2 엔터 크리티컬 섹션에 들어가기 전에 나 들어갈 수 있어 그럼 물어봐야 돼요.
그리고 엑시트 섹션 엔덴 리메인더 섹션 이런 거를 나눌 수도 있는데 메이 팔로우 할 수 있다는데 메이에요.
메이드 퍼스비 위주 같이 여러분 메이는 강제가 아닙니다.
옵션입니다. 메이디 드 당연히 알겠죠. 이거 모르는 사람이 우리 컴퓨터과에 있진 않겠죠.
스타워즈에서 나오는 항상 그 인삿말이죠. 그래서 스타워즈 데이라는 게 있어요.
여러분 설마 아시겠죠? 스타워즈 데이가 며칠인지 그냥 이 들이 만든 거죠.
기들이 만든 건데 글자들이 많은데 메이 오얼로 해석을 하고요.
이 메이가 그 메이는 아니지만 폴스를 폴드로 번역을 해서

33:04
5월 4일 즉 메이퍼를 스타워즈 데이로 우리는 보통 얘기합니다.
그날 되면 이런저런 이벤트들이라든지 뭐 그런 것들이 많이 생깁니다.
스타워즈 팬들은 크리티컬 섹션 제너럴 스트럭트 o 프로세스 PI 하나 예제를 하나 들겠습니다.
여러분 보통은 이렇게 돼 있어요. 프로세스 PI가 있는데 이건 아예요.
제가 아니라 i 인덱스를 i라고 하고요. 어떤 얘는 수행을 하는데 언제까지 와 트루 그러니까 항상 항상 이 내용을 수행을 하는데 엔트리 섹션 어딘가에 딱 들어갈 때 엔트리 섹션이 있고요.
크리티컬 섹션이 들어가고 엑시트 섹션이 있고 리메인터 섹션 나머지를 한다는 거예요.
그러니까 프로그램을 수행하는데 중간에 어떤 조건이 되면 그러니까 엔트리 조건이 되면은 이 안에 들어가서 CS를 수행하고요.
그다음에는 나와 있고 나와서 나머지를 리메인더 그냥 REM이라고 쓸게요.
나머지를 수행한다는 거예요. 그렇게 하는 게 보통 일반적이라는 거죠.

34:19
그럼 질문이 나올 수 있죠 q 학생들 중에서 수업 시간에 있으면은 여러분 그 수업을 제가 오프라인에서 할 때는 재미가 있어요.
왜냐하면 제가 여러분들한테 이런 질문을 막 던집니다.
이거 왜 이렇게 설계를 했을까 이런 질문하고 여러분들의 반응 보고 이렇게 기다리고 여러분들이 이런저런 의견도 얘기하고 그러면 시간이 참 재미있게 가는데 온라인에서의 좀 아쉬운 점이 이거죠.
지난번에 코비드 수준이 좀 내려갔길래 한번 오프라인 수업을 해볼까 싶었더만 당장 또 금방 200명 넘게 올라가고 또 우리 학교 지금 저기 학생회관에 그 환자가 또 생기고 그런 문제가 있어서 아이고야 역시 안 되겠구나 그러니까 항상 이래요.
좀 괜찮아졌다 해서 마음을 한번 해볼까 애들 얼굴도 보고 같이 좀 그럴까 하면은 다른 사람들도 이제 마음이 풀려서 휴가를 다녀오고 뭐 이러고 그러다가 결국은 또 수급자가 증가하고 그러니까 또 못하고 반복이네요.

35:26
함부로 또 한다고 그랬다가 숫자 올라가면 또 다 취소해야 되니까 그것도 문제고 여러분들도 지방에 사시는 학생들은 계속 이러니까 집에 고향에 내려가서 온라인 수업을 듣고 이러는 학생들이 있어서 갑자기 이제 오프라인 수업을 한다면 그 친구들한테는 도리어 또 그게 문제가 되기 때문에 일단 온라인 수업을 계속합니다.
그런데 교수 입장에서는 참 재미가 없어요. 이런 걸 같이 얘기를 못해서 그래서 q는 뭐냐 시가 뭐냐 왜 CS 구간의 엔트리 조건과 시 조건을 시 조건이라기보다는 엑시트를 이 단계를 만들고 나머지 리메인드 파트는 여기를 하나 그냥 처음부터 모든 거를 다 그냥 이렇게 여기서부터 시작해 이 조건에 해당하면 여기서 시작하고 여기서 끝나 프로그램 처음과 끝에다가 엔트리 그다음에 여기선 액시 섹션 하면 어떠냐 이거예요.
쫙 수행되게 중간에 CS 중요한 부분도 있을 거고 이렇게 하면 왜 안 되느냐 만약에 여러 가지 프로그램들이 동시에 프로세스를 도는데

36:38
이렇게 그리디하게 그리디하게 욕심쟁이처럼 코드를 다 CS 섹션을 난 전체라고 해 난 정말 다 중요하니까 일단 내가 수행되면 아무도 내 거 건들지 마 이런 식으로 디자인이 돼 있다라고 하면요.
얘가 수행되는 동안 다른 애들은 수행을 못하고요.
얘가 수행되는 동안 또 다른 애들이 못하고 뭐 이런 식으로 코드가 돌아가면 병렬화 패럴라이제이션 패럴라이제이션 이런 거나 전체적인 시스템 퍼포먼스가 시스템 퍼포먼스 퍼포먼스가 현격하게 떨어질 겁니다.
안 좋죠 그러니까 어떻게 하냐면 정말 중요한 크리티컬 섹션 부분만 야 여기는 제발 건들지 마 딴 거는 괜찮은데 여기는 내가 수행할 땐 리소스 좀 나한테 할당해서 건들지 마.
내 리소스는 일단 건들지 마 다른 리소스야 상관없지만 그렇게 해놓고 이 구간을 그러니까 짧게 만드는 거예요.
최대한 쇼트 하게 만들고요. 나머지를 리메인더 파트를 리메인더 섹션은 천천히 하면 되죠.
여기는 남이 들어오든

37:52
중간에 테스크 스위칭에 대해서 뭘 하든 별로 아이도 키어다 이거예요.
그래서 중요한 부분만 뺀다 이 개념으로 보시면 됩니다.
여러분들 중에서 이제 선생님을 노리고 그 시험을 보는 친구들은 여기서 막 이렇게 코드 배우고 막 이렇게 나와도 이렇게까지 디테일하게 나오지 않고 주로 여러분들 뮤추럴 익스클루전부터 시작해서 이제 그러니까 바틀랙을 피하는 어떻게 보자면 그런 우리 제목이 처음에 뭐였죠? 우리 그 싱크로나이제이션 나오고

38:31
어

38:32
데드락 어버이 다스 나오죠 이 데드락을 이 데드락 서로 걸려가지고 아무도 병목 현상이라고도 하는데 교차로에서 얘가 막 갈고 있었어요.
근데 중간에 신호등이 바뀌었는데도 막 얘가 가서 이렇게 딱 박혀 있고 얘도 가려다가 이거보다도 이거다.
얘가 일로 좌회전을 하려고 하고요. 얘는 일로 우회전을 하려고 하고 얘는 일로 좌회전을 하려고 그러고 얘는 일로 좌회전하려고 서로 이럴 때 서로 꼬여가지고 아무도 못 가고 이렇게 있는 그런 거 있죠 이런 걸 데드라그라고 합니다.
그러면 어떻게 해야 되죠? 방법 솔루션 경찰 아저씨가 투입이 됩니다.
그래서 아저씨가 가가지고 아니면 모범 택시 아저씨가 가서 헤이 일단은 수신으로 해서 네가 먼저 가 그다음에 니가 가고 그다음에 니가 일로 가고 너는 욜로 가고 이거 이거 해주면 풀리잖아요.

39:34
응

39:36
그거를 원하는 겁니다. 선진국과 후진국까지는 아니지만 옛날에 제가 경험한 것 중에 하나 제가 샌드웨고에 있을 때 그 한 번은 그 지역에 얘기를 제가 지난 학기인가 한 번 다른 수업 시간에 얘기한 적 있습니다.
원자력 발전소가 있는데 그게 이제 거기서 들어오는 전력 전송하는 전력 전송하는 시스템에 문제가 생겨서 샌디에고 전체가 정전이 한 하루 반 정도 하루 정도 넘게 간 적이 있었어요.
그래서 갑자기 회사에서 막 서버가 다운되기 시작한 거예요.
처음에는 처음에 PC가 다운됐어요. 서버는 살아있죠.
왜냐면 무정전 시스템 ups라고 하죠.

40:28
그

40:28
무정전 시스템은 거기에 배터리를 가진 전원 장치가 있어서 몇 시간 이상은 적어도 돌아가게끔 해주는 건데 그것도 버티다 버티다 다운이 되고요.
방송국들이 그다음에 다 이제 내려오는 거예요. 전기가 없으니까 그렇게 해서 막 다운이 돼서 도시 전체가 완전히 그 블랙아웃 현상이 일어났는데 그때 이제 회사에서 집에 가라는 거예요.
그래서 집에 가는데 집 근처에 오니까 이제 신호등 교통 체계에 신호등까지도 다 다운이 됐어요.
그러니 이게 난리가 난 거죠. 그런데 거기도 그 도로가 꼭 이런 데가 이제 나오는 거예요.
사거리 퀄컴 앞 사거리 컬컴 있는 그쪽 사거리 우리 소렌토 밸리라고 그러는데 여기 문제가 이제 이런 문제가 생겨 얘 일로 가고 얘 일로 가고 이거 이 문제가 생기는데 이게 신호등도 없고 경찰도 없는데 어떻게 되냐 하면 애들이

41:24
이런 식이에요. 여기 차들이 이렇게 막 줄 서 있죠.
차들이 이렇게 막 줄 서 있고 얘도 줄 서 있고 막 이렇게 서 있고 그러는데 그냥 온 순서대로 얘가 예를 들면 얘가 일로 가려고 그러면 일로 가요.
그다음에 얘가 자기 순서다 싶으면 얘는 뭐 일로 가고요.
여기 있고 얘는 또 그러면 자기 순서면 얘는 욜로 가고 그다음에 얘가 또 1로 가고 얘는 또 욜로 가고 이거를 온 순서대로 번갈아가면서 1 2 3 4 이런 식으로 하여튼 자기 순서를 기다려서 그 하나씩 그러다 보니까 느리죠.
왜냐하면 사실 이런 교차로에서 이럴 수 있잖아요.
여기 차들이 속도를 내서 한 10대가 쭉 일로 달려가고 그다음에 10대가 쭉 달려가고 10대가 쭉 일로 가고 이렇게 하면 성능이 빠르죠.
왜냐하면 멈췄다 갔다 멈췄다 갔다를 안 하니까 근데 성능은 빠르나 이 페어니스 문제가 있죠 페어니스가 근데 이거를

42:24
얘네들은 이렇게 해서 풀더라 이거예요. 신호등도 없고 경찰도 없고 아무것도 없는데 막히지가 않아요.
느리지만 막혀 그러니까 좀 정체되지만 갈 차들은 하여튼 하나씩 하나씩 다 가고 사거리가 이 병목 현상이 안 생기더라 이거예요.
되게 놀랐던 기억이 납니다. 그리고 언제 회사를 가야 될지 연락을 받을 방법도 없고 인터넷도 안 되고 그래서 지역이 tv도 안 되고요.
방송국도 안 되는데 라디오 방송국이 이웃 도시나 이런 데서 되기 때문에 기억이 그때 집에서 회로 솟아가지고 라디오를 조립했어요.
그래서 그게 있었어요. 그런 장치가 그래서 라디오를 조립해서 그 라디오 가지고 소리를 듣다가 어느 순간에 이제 전기가 내일 오전 몇 시까지 들어온다 해서 그때 회사를 갔던 기억이 납니다.
일단 저런 병목 현상

43:21
응

43:23
그거 어떻게 못 보나 유튜브 이런 광고들이 많네요.

43:33
자

43:37
어떻게 보지 못 보나 유효 채널

43:47
8,090 이런 것도 제 채널이라고 이거 이거 이겁니다.
제가 보여드리고 싶었어요. 이거를 만들었었어요.
데이의 과학이라고 이게 1980년대에 있던 그런 장치들인데 이게 이제 오래됐는데 그걸 추억하는 사람들이 일본에서 다시 만들어서 팔았는 거를 2천년 정도에 와이프가 저한테 선물을 해줬었어요.
연애하던 시절에 그래가지고 이거 갖고 장치를 만들었죠.
라디오를

44:22
그렇죠

44:34
그래서 라디오가 됩니다. 이게 이런 장치 이 안에 회로가 들어 있어요.
소자들이 그래서 저거를 잘 끼워서 만들 수 있는 거죠.
네 하여튼 저거를 만들어서 그 당시에 그거를 해결했던 기억이 납니다.

44:56
참 재밌던 시절입니다. 여러분들 우리 it 기계 됐으면 좋겠습니다.
여러분들도 선생님들이 이제 아까 제가 선생님 얘기를 왜 했더라 저 얘기입니다.
선생님 얘기는 왜 했었냐면은 이 실제로 우리 데드록 어버이던스를 하기 위한 기법들이 한 4가지 이런 게 나옵니다.
뒤에 나와요. 그런 것들이 무엇이고 그거 중에 아닌 것은 이런 거 고르는 거 시험 문제들이 나올 수 있습니다.
그래서 실제로 이 챕터에 대해서 시험 문제는 쉬워요.
제가 봤을 때 상대적으로 그렇게 어려운 문제가 나올 수 없고요.
제가 이번에 공동으로 하는 과목에서 운영 체제 기출 문제들을 뽑아가지고 학생들한테 풀어주고 그랬는데 그거를 여러분들한테 제가 문제는 좀 공유해드릴 수 있어요.
어차피 그 수업 시간에도 배울 수 있지만 제가 좀 자료를 올려드리도록 하겠습니다.

45:57
보면은 기출 문제들 보면은 이 챕터는 부담스럽지 않고 주로 이제 스케줄러 그리고 메모리 매니지먼트 할 때 버추얼 메모리 뭐 이런 부분에 계산하는 문제라든지 그런 부분이 시험에 나옵니다.
요새는 다 주관식으로 나오고요. 또 어쨌든 이 부분은 좀 쉬운 편입니다.
그래서 일단 마음 편하게 보시고 코드 나오고 그럴 때 100% 다 이해가 안 가도 너무 부담을 느끼지 마시기 바랍니다.

46:26
그리고 여러분들 중에 그 코멘트 중에 강의 우리 중간 평가 같은 거 할 수 있잖아요.
제 강의에 대해서 늘 그렇지만 좀 허브로가 갈 수도 있습니다.
어떤 분들은 제 강의에 구현하고 이런 시스템 하는 걸 좋아하시는 분들이 있고 또 어떤 분들은 너무 막 그렇게 텀 프로젝트 내주고 그런 거 하지 마세요.
제발 힘들어요. 이런 분들도 있는데 사실 여러분 모든 사람을 다 만족시키기가 어려운 게 있어요.
그러니까 제가 제가 예를 들면 개인적으로 좀 이런저런 뭔가를 하다가 강의를 제때 못 올렸다 이거는 제가 이건 개선을 해야 될 문제예요.
그건 뭐 FTR 명백하게 아주 그건 그 문제지만은 그런 게 아니라 이렇게 강의의 방향이나 어떤 스타일에 대해서는 사람마다 조금 다른데 저는 텀 프로젝트를 내드리는 거를 선호합니다.
여러분 아시는지 모르겠지만 텀 프로젝트를 여러분들한테 내드리면은 저나 저희 조교들은 되게 힘들어요.
질문들도 많이 받고 그 채점도 굉장히 번거롭고 되게 힘든데

47:32
그렇게 안 하면 여러분들이 실력이 잘 늘지 않을 것 같고 우리가 컴퓨터 교육과이긴 하지만 임용고시 보는 학생들만을 위해서 그런 코딩하는 거는 그렇게 시험 문제에 직접 나오지 않으니까 이러고 빼버리면은 또 나머지 한 반수 정도 되는 학생들에 대해서는 또 좀 부족한 게 있기 때문에 텀 프로젝트도 같이 수행을 하고 있습니다.
그리고 늘 말하지만 교사가 됐을 때 요새는 아주 더 어떻게 보자면 높은 수준의 코딩 실력을 요구할 수도 있습니다.
앞으로 정보 교사분들에 대해서는 진짜로 인공지능 수업도 하고 파이썬으로 코드도 쓰고 그래야 될 수 있습니다.
콜랩도 쓰고요. 그러니까 일단은 좀 믿고 따라와 주시기 바랍니다.
알고리즘 프로세스 PI 계속할게요. 코드가 이런 식으로 되면 어떨까요? 와일 아까 두 와일은 여기가 2루니까 계속 수행이 되는데 와일 턴이 내 차례냐 아니냐 그걸 나타내는 턴입니다.

48:39
차례가 만약에 j면 나는 지금 i죠. 그러니까 프로세스 i가 있고 프로세스 j가 있고 두 개가 서로 레이스 컨디션처럼 니가 했다 내가 했다 네가 했다 내가 했다를 막 오가고 있어요.
그런 상태에서 만약 제2차라면은 어떻게 해야 되죠? 가만히 기다려야 되죠.
그래서 이 세미콜론이 있어요. 잘 보면은 얼추 잘못 보면 이래요.
여러분 어떻게 보냐면 얼추 잘못 보면 이 조건이 되면 이걸 하라 이렇게 마치 여기 이렇게 이게 있는 것처럼 이렇게 생각할 수 있는데 아니에요.
여기 세미콜론이 있어요. 세미콜론이 있다는 얘기는 뭐죠? 요거 턴 제이면은 아무것도 안 하고 여기서 그냥 계속 와일 돌고 여기서 기다린다는 거예요.
즉 제가 수행대를 차릴 때는 가만히 있다가 이제 이게 아니면 no j이면 크리티컬 섹션 자기 크리티컬 섹션으로 딱 들어가고요.
들어감과 동시에 턴을 j는 턴

49:43
아

49:44
들어감과 동시가 아니라 크리티컬 섹션을 수행하고요.
크리티컬 섹션이 수행이 끝나자마자 제이한테 자기 차례를 넘겨줍니다.
그래서 톤은 다시 제야 제이 니가 해도 돼요. 그러면은 j는 이제 수행될 수가 있는 거예요.
그다음에 자기는 나머지 거를 천천히 수행을 합니다.
그러면 코드 제가 여러분들한테 이 코드를 주고 그러면 j는 어떻게 쓸까 프로세스 p j는 어떻게 쓸까 똑같죠 두 이거 하는데 와일 이렇게 된 거죠.
턴은 턴이 아이면 크리티컬 섹션 하고 그다음에는 턴은 아 그다음에 리메인더 이렇게 되는 거죠.
와 수행하는데 프로세스 제의 입장에서는 턴이 만약 아차라면 가만히 기다려 여기서 콜론 있습니다.
있습니다. 가만히 여기서 계속 돌고 뱅글뱅글 돌고 기다리다가 이게 자기 차례가 돌아오면 CS를 딱 수행을 하고요.
CS가 끝나면 다시 아이 차례로 넘겨주는 거예요.
그러니까 코드 하나 써가지고

50:59
자기 프로세스의 넘버가 아닌 것이 여기 들어오는 거죠.
어떻게 보자면 톤이 자기 게 아닌 것을 해당하는 거죠.
그래서 이런 식으로 코드를 쓰면 서로 오가면서 뭔가를 할 수 있고 크리티컬 섹션을 보호할 수 있다 그런 생각을 할 수 있는 겁니다.
이게 근데 이제 구현이 되느냐 이거 여러분들이 이 책에 교재에서 한 가지 주의하실 점이 이거는 어설픈 그 사람이 코드를 책을 쓴 게 아니라 연구를 하고 굉장히 OS에 대해서 심도 있게 설계를 했던 사람이 쓴 거라서 거의 연구 논문처럼 앞에서부터 계속 이런저런 기법들이 막 나옵니다.
이 기법 다 가르쳐놓고 나서 그럼 이거 하면 되나 보다 하면 다음 부분에 어떻게 나오냐 하지만 위의 기법은 무슨 문제가 있었다 그래서 이렇게 해야 된다.
그럼 그럼 이렇게 하라는 말이구나. 근데 갑자기 끝에 가서 또 하지만 그 기법의 경우는 또 이러한 문제가 있다 그래서 이렇게 해야 된다 이게 계속 나와요.
그럼

51:58
나머지 사실 어떤 면에서 배울 필요 없고 이것만 배워도 된다 이렇게 볼 수 있죠.
마지막에 이것만 배우면 어떠냐 이렇게 할 수도 있는데 그런다면 사실 뭐 공부할 게 너무 없죠.
그리고 나서 그 과정에서 어떤 식으로 그게 디자인됐는지도 우리가 이해하면 좋아서 제가 이걸 교과서에 나온 내용을 그래도 다 조금씩 다룹니다.
너무 중요하지 않은 거 빼고는 다 다루는데 이 과정에 최고의 단점이 하나 있어요.
이걸 다 배우고 나면 그래서 도대체 어떻게 하라는 거야 좀 헷갈려라고 얘기를 할 수가 있어요.
그렇기 때문에 제가 여러분들한테 미리 말합니다.
마음 편하게 그냥 이런 게 있나 보다 하고 끝에 가서 결론은 뭐냐면 아토믹 아토믹 한 원자를 말하죠.
이제 분리가 안 되는 원자 그래서 크리티컬 섹션에 들어간 이런 코드를 엔트리 조건 나오는 코드를 하나의 명령어로 처리할 수 있도록 만든 다음에 하드웨어 명령어로 처리합니다.
하드웨어에 어떤 명령어를 하나 둬서

52:55
이 조건이 만족하면 이로 들어갈 수 있게끔 하는데 이 조건을 수행하는 중간에는 이 과정에서는 스위칭이 안 되도록 그런 아토믹 하드웨어 옵션을 둬서 처리하기 때문에 이게 답입니다.
이게 답이고 그럼 이런 과정들을 교수님 왜 배우나요? 개념적으로 이해하기 위해서 배우니까 나머지는 그냥 이런 게 있구나 하고

53:22
어

53:23
100%의 어떤 이해력까지 아니고 한 80~90%의 이해력으로 팔로업 하시면 되겠습니다.
솔루션 크리티컬 섹션 프라브럼 근데 크리티컬 섹션을 하는 경우에 또 문제가 좀 있다 이거예요.
이거 벌써 또 문제가 있다니 또 긴장되죠. 도대체 또 무슨 문제냐 뮤추럴 익스크루존 프로그래스 바운드드 웨이딩 요 조건들이 중요한 겁니다.
뭐냐면 서로 상호 배제 아까 말했죠. 상호 배제는 만약에 프로세스 PI가 수행이 되고 있으면 익스티링 하고 있으면 스크리티컬 섹션에서 CS에서 지금 돌아가고 있으면 no AD 프로세스 캔 익스큐링 다른 애들은 동작하면 안 된다 인데 크리티컬 섹션에서 하면 안 된다 이거예요.
그러니까 서로 간에 상호 배제 야 우리 야 우리 친구들끼리 그러는 거 아니야 알았지 이렇게 하고서는 하는 상호 배제가 이루어져야 된다 이거예요.
솔루션이잖아요. 크리티컬 섹션의 문제를 해결할 수 있는 솔루션 프로그래스 프로그래스는 전진 진보화할 때 그런 전진 이런 얘기죠.

54:37
노 프로세스 익스큐링 인크리티컬 섹션 만약에 아무 프로세스도 수행되고 있지 않다면 크리티컬 섹션 CS에서 수행되고 있지 않다면 그러면 그리고 GS SM 프로세스 ws 엔터 d 크리티컬 섹션 다른 프로세스들 중에서 CS에 들어가고 싶은 어떤 프로세스들이 존재하고 있다면 그러면 셀렉션 프로세스 엔터 크리티컬 섹션 나비 포스트 폰드 디파이n트리 그러니까 이게 뭐냐 하면 이걸 무제한적으로 그러니까 무기한적으로 그 말이니까 그 무기한 연기되지 않는다니까 어떤 놈이 좀 들어가서 쓰려고 그럴 때는 그리고 지금 안 쓰고 있고 그러면 걔가 무기한적으로 기다리지 않고 그 수행이 돼야 된다는 거예요.
네 그 얘기를 이제 우리가 프로그래스라고 해가지고 얘기하는 겁니다.

55:42
그렇죠

55:44
그러고 바운드드 웨이링은 기다릴 때 한 개는 좋아 바운드는 여러분 한 개죠.
어디 바운드까지 한계죠. 그 한계까지만 기다려 그러니까 너무 무제한 비슷한 거죠.
사실 그러니까 딴 놈이 들어가 안 쓰면 그냥 이거는 들어가게 해주라는 거고 바운드 머스트 이그지스트 해야 된다.
온더 넘버 오브 타임스 댓 아더 프로세스 아웃 라우드 투 엔트 데어 크리티컬 섹션스 애터 프로세스 해 메이더 리스 엔트롤 스 크리티컬 섹션 앤 비 리퀘스트 그렌티드 리퀘스트가 그렌티드 허락될 때까지 전까지는 언젠가는 하여튼 선이 있어야 된다 이거예요.
어 de eh 프로세스가 익스큐를 하는데 넌 제로 스피드 이건 이건 별로 중요하지 않고요.
여러분들이 하여튼 바운디드 한계가 있는 웨이링을 한다.
그러니까 어느 정도 기다리는 데도 참는 데도 한계가 있으니까 정해져 있어야 된다는 겁니다.
한 놈이 쓰면 딴 놈 못 쓴다. 안 쓰고 있으면 들어가서 쓴다.
그리고

56:58
안 쓰면 쓴다. 그다음에 기다릴 때는 그 선이 있다.
그 정도 조건을 통해서 합니다. 여기다 제가 한글로 참 번역을 해놨네요.
이거 여러분들이 이런 경우가 있어요. 영어로 이렇게 써놓으면은 자기가 이해가 잘 안 가는 상황에서 원서나 이거를 보고 퍼뜩 이해가 안 가면 어이쿠야 하는 분들이 있어서 이걸 제가 조금 해놨습니다.
상호 배제라고 아까 한글로는 하는데 하나의 프로세스가 임계 구역에 CS에 들어가 있다면 다른 애들은 갈 수 없어야 된다.
이게 첫 번째 조건이 진행 임계 구역에 들어간 프로세스가 없는 상태에서 어떤 애가 들어가려고 하는 애가 여러 개 있다면 어느 것이 들어갈지를 적절히 결정해 줘야 된다.
그래서 뭐 진행이 되는 겁니다. 그러고요. 한정되기는 다른 프로세스의 기아 스트라베이션 스트라베이션을 막기 위해서 한 번 임계 구역에 들어간 프로세스는 다음번 임계 구역에 들어갈 때 제안을 이거를 이렇게 번역을 해 잠깐만요.

58:18
넘버 타임 아들 프로세스 라우 2 엔터 대 크리티컬 섹션 애프터 프로세스 해 메이더 리퀘스트 엔터 리스크 섹션 mdf 리퀘스트 그랜드 한 놈 들어가고 나서 그다음에 할 때까지는 넘버 오브 타임스를 갖다가 존재해야 된다.
그러니까 그걸 그렇게 해석해 그러네요. 근데 그러니까 결국은 한 놈이 독점해서 계속 쓸 수가 없어요.
이렇게 되면 한 번 임계 구역에 들어간 프로세스는 다음번 임계 구역에 들어갈 때 제한을 두어야 한다 그런 얘기입니다.
그래서 한 녀석이 계속 들어가지 않고 제한을 두니까 결국은 사실 어떻게 보자면 그러면 바운데드 웨이딩은 기다리는 거가 무제한으로 넘어가지 않게 이게 결국은 자기 선이 있습니다.
이거의 문제가 2번 3번이 있습니다. 소프트웨어적인 방법이 있으나 복잡하다.
그래서 CPU가 지원하는 동기화 명령어를 활용해서 뭔가를 하자 그러다 보니까 어터밍 레벨에 하드웨어적 명령어를 쓰는 것이 결과적으로 나중에 뒤에서 나오지만 방법으로 나옵니다.

59:31
피로 쓴 솔루션 이거 배워봐야 의미가 없습니다. 뒤에 가면 그렇게 쓰면 또 무슨 문제가 있고 그거가 나온다는 게 이런 겁니다.
그래서 배워봐야 할 필요가 없다는 거는 좀 너무 심한 얘기고요.
이조차도 또 그런 이슈가 있습니다. 그래서 여러분들한테 지금 조금 설명을 드리면 아이구야 이거 이거 이거 하고 나면 힘 빠지는데 피터 솔루션 이거 이거 제가 여기다 물음표해 놓고 이거 여러분들한테 한번 생각해 보라는 그 얘기인데 제가 이거 예전에 학생들한테 설명을 해줬었어요.
플래그를 두고 차례를 두는 거 이게 뭐냐면 아까 전에 우리가 내 차례냐 아니냐 이거 턴 i와 턴 제 가지고 이거 했었죠.
PI는 여기 여기 코드 나오는 거에서 요거 이거 가지고 이제 우리가 PI가 턴 j 이거 가지고 이제 키고 끄고를 한다고 보시면 되는데 들어가고 말고를 그렇게 하면 또 무슨 문제가 있으니 플래그를 하나 둬서 내 차례 아니냐 기냐를 플랙으로 들어갈 차례냐 아니냐

1:00:58
차례가 폴스냐 추루냐 이런 걸 두자 이거예요. 그다음에 엔드로 조건을 만들자 이건데 이렇게 해도 문제가 생겨요.

1:01:05
응

1:01:07
이렇게 하면 뭐 괜찮냐 아니에요. 이렇게 해도 문제가 생길 수 있습니다.
이거는 피터슨이라는 솔루션이라고 하는데 완벽하지 않아요.
그래서 이제 결과적으로 싱크로나이제이션 하드웨어라고 해가지고 하드웨어적으로 아토믹하게 그러니까 no 인터럭터블 중간에 인터럽트를 받을 수 없도록이니까 아토믹은 원자 쪼갤 수 없잖아요.
분자가 원자로 쪼개지고 뭐 어쩌고 저쩌고 있지만 쪼개질 수 없는 최소한의 단위를 아토믹이라고 그러는데 그 단위로 하드웨어적 명령어를 써서 하드웨어적 명령어는 인스트럭션이 하나의 인스트럭션이라고 봐야 되죠.
하나의 인스트럭션을 처리하는 그 하드웨어가 하나의 인스트럭 하나의 인스트럭션 사이클에서 아까 말한 들어갈 조건 예를 들면 뭐가 내 차례냐 키가 추르냐 폴스냐 이런 거를 갖다가 수행되도록 하드웨어적으로 보장을 해주는 거예요.
그러면 그거 체크하고 들어가면 되니까 뭐 어렵지 않죠 이렇게 하면 굉장히 쉬워지는 거예요.
이렇게 하면 아무 문제가 없는 건데

1:02:21
이게 없을 때 이걸 소프트웨어적으로 구현하려고 저런 문제들이 생긴 거예요.
저런 문제는 왜 생겼냐 옛날에 프로그램을 짜가지고 멀티 트레이딩 멀티 프로세싱을 하다 보니까 서로 엄청 레이스 컨디션 컴퓨터는 빠르니까 그런 것들이 있을 때 문제가 되더라 이거예요.
문제가 생겨가지고 이거 어쩌지 하다가 결국은 그럼 솔루션으로 이렇게 해볼까 저렇게 해볼까 하다가 결과적으로 그렇게 해도 안 되고 이렇게 해도 안 되니까 아터믹한 하드웨어 도움을 받자라고 결과가 나왔습니다.

1:02:53
응

1:02:54
일단 앞에 조금만 더 읽어보죠. 베니 시스템 프로바이더 제공한다.
하드웨어 서포 인프리맨팅 크리티컬 섹션 코드를 하기 위해서 구현하기 위해서 하드웨어 서포트를 받는다 그거고요.
o 솔루션스 빌러 베이스 아이디어 럭킹 럭킹 아이디어를 썼는데 쭉쭉쭉 나가고요.
커런트릭 러닝 코드 우드 익스큐트 위더 프리엠션 프리엠이 뭔지 알죠? 그 선점해가지고 언제나 얘가 쓰고 있어도 또 다른 애가 들어와서 또 쓸 수 있는 그러니까 선점 비선점 얘기할 때요.
넌 프리엠 프리엠션 있죠? 쓸 수 있느냐 없느냐 그게 이제 프리엠션 n프리엠션이죠.
그거 얘기고요. 지금 나와 있는데 요거 쪽은 좀 여러분이 그냥 적당하게 이렇게 보시고 이게 보지 말라는 얘기라기보다는 적당하게 보시고요.
저는 여러분들이 여기서 요거 요거를 좀 잘 기억했으면 좋겠습니다.
모던 머신들은 프로바이 스페셜 아토믹 하드웨어 인스트럭션을 제공해서 아토믹하다는 건 여기서 넌 인터럽터블 중간에 인터럭터블 안 당하는 걸로 해서 저기

1:04:24
이 문제를 크리티컬 섹션 문제를 처리한다 이겁니다.
크리티컬 섹션 코드를 즉 싱크로나이제이션을 해준다 그 얘기입니다.

1:04:34
네

1:04:35
그래서 이제 솔루션 2 크리티컬 섹션 프라브럼 뉴징 락스 여러분들이 이제 락을 이용해서 아까 전에 여기 락이 좀 락킹 나오죠 락킹 기법을 이용해가지고 여기 프로텍팅 크리티컬 섹션을 락을 한다.
이거 뭐 우리 아까 잠그는 자물쇠 얘기인데 어쿼이어 락을 취득하면 CS에 들어갈 수 있고 CS가 끝나면 릴리즈를 하고 나머지를 한다.
결국은 계속 그거예요. 어콰이어 락을 하고 릴리즈 락을 하나 아까 전에 요거였었처럼 플래그를 보고 내 차례냐 아니냐 턴 이거 보고 들어가서 CS를 하고 그다음에 리드를 나와서 리메드를 하나 아니면 여기서처럼 턴 상대편 차례면 세미콜로니까 기다리고 CS를 하고 그다음에 끝나면 키 돌려주고 나머지를 하나 다 같은 얘기잖아요.
지금 그 얘기가 반복되고 있죠. 뭔가 조건이 만족 즉 남의 차례가 아니라 내 차례가 되면 CS를 하고 끝나면 알려주고 조건을 바꿔놓고 나머지 리메인더 한다.
이 얘기가 지금 계속 나오는데

1:06:01
개념적으로 락을 두면 어때라고 하는 거예요? 그 앞에 거랑 똑같은 얘기예요.
근데 이후 몇 가지 솔루션이 교재 등에 나와 있으나 잘 안 쓰이는 관계로 스킵 제가 이렇게 스킵해놓은 거 이유가 있어요.
별로 이렇게 해가지고 이게 안 됩니다. 이게 교재를 좀 굉장히 우리 교재가 두껍죠.
사실 처음 운영체제 교재 공룡 책 딱 보면은 진리죠.
이거를 다 봐야 돼 한 학기 다 보실 필요가 없습니다.
지식이 계속 쌓여가는데 모든 거를 다 굳이 이렇게 알 필요는 없죠.
그럴 시간과 에너지의 선택과 집중을 위해서 다른 걸 하는 게 나으니까 제가 봤을 때 여러분들이 그냥 솔루션은 요거 하드웨어적인 아토믹 솔루션으로 이해를 하시고요.
이런 기법들 이런 비슷한 이런 방식을 쓴다 걸고 CS하고 조건 바꿔주고 리메인드 한다 리메인드한다 이런 식으로 그냥 한다라는 것만 알고요.
요 세세한 노력들은 이렇게도 해보고 저렇게 해보고 했는데 그럼에도 불구하고 중간에 어셈블리 레벨에서

1:07:08
인터럭트가 발생해서 스위칭이 되고 하면 문제가 결국 이렇게 생길 수 있고 저렇게 생길 수 있어서 완벽한 솔루션이 없다 이렇게 보시면 됩니다.

1:07:17
네

1:07:18
그래서 이제 아까 록 솔루션 나오고 뭐 그런데 뮤추얼 록 합니다.
뮤추얼 록 그게 이제 뮤추얼 록이 나와서 텍스 추락 그러니까 뮤텍스가 뮤트럴 익스클루 락이죠.
이게 뮤텍스가 뮤추럴 익스클루 상호 배제한다는 거죠.
그래서 서로 간에 상호 배제되는 락을 두는 기법을 얘기하는데 이걸 제가 좀 설명을 드릴게요.
일단 프리비어스 솔루션들을 이전에 막 앞으로 아까 전에 나온 솔루션들은 컴플리케이티드하다 복잡하다.
그리고 제너럴리 일반적으로 i 억세서블하다 실제로 잘 쓸 수가 없다.
어플리케이션 프로그래머들이 하기에는 이거 이렇게 복잡해 잘 못 쓰겠어 이런 거예요.
그러니 이 문장을 처음 보기 전까지 여러분이 책을 꼼꼼히 읽어보면서 아싸 이러고 공부했다가 이 문장을 만나는 순간 멘붕이 오는 게 뭐야 그럼 이제까지 앞부분에서 공부한 거 다 필요 없다고 그게 되는 거예요.

1:08:15
그리고 여기 보면 osd 디자이너들은 빌드 소프트웨어 툴스를 한다 만드는데 to SUV 크리티컬 섹션 프로그램을 해결하기 위해서 뭔가 소프트웨어적인

1:08:30
네 방법을 만들고자 했어요. 근데 이제 심플리스트 이스더 뮤텍스 락이라고 하는 겁니다.
심플리스트가 프로텍트 크리티컬 섹션을 바이 퍼스트 어쿠이어 락 댄 릴리스 락 락을 얻고 그러니까 자물쇠를 가지면 들어가고 그다음에 반환하고 이걸 가지고 간단하게 이제 우리가 크리티컬 섹션을 보호한다 이거죠.
그런 거고 블린 베어리어블이 인디케이링 ift ris 어베일러블 o 나타낸다 이거예요.
그래서 예를 들면 제가 블 그러고 시에서

1:09:11
c에서 불 해놓고 마이턴 마이턴 해놓고 기본적으로는 예를 들어 폴스로 해놓은 상태에서 이 마이톤 보고 내 차례가 맞느냐 틀리냐 보고 그냥 예를 들면 ef 마이 턴이면 코드 어디 CS를 이제 들어가서 처리해라 이렇게 해놓고 아니면은 해라 그다음에 나올 때 턴 바꿔놓고 턴은 마이턴은 트루 이렇게 바꿔놓고 아니면 폴스에 놓고 이런 식으로 코드를 쓰면 이거 이거 얼추 될 것 같잖아요.
근데 그것도 안 돼요.

1:09:49
네

1:09:50
이게 여러분 제가 이거 지금 여기다 코드를 쓸 공간이 조금 없는데 어셈블리 레벨에서 보면요.
여러분 이런 거예요. 이거 어셈블리까지 했으면 여러분 잠이 오니까 이번 수업도 뒷부분인데 여러분들이 조금 덜 잠 오게끔 좀 쉽게 설명을 하면 이런 겁니다.
화장실에 들어가서 우리 그 문을 아까처럼 여기 문이 그 화장실에 들어가면 여기 문에 아큐파이드 또는 그 베이컨스 바꾸는 거 여기 여기 있는 거 있죠? 이거에다 대고 만약에 이게 베이컨스면 들어가서 이거를 어큐파이드로 바꿔야 되는 거예요.
바꿔놓고 자기가 쓰고 쓴다는 얘기는 CS가 되고 나와서는 다시 나올 때 나와서가 아니죠.
나올 때 베이컨시로 바꿔놓고 나오면 된다. 리메인도 한다 뭐 이렇게 생각하시면 되는데 이 문제가 어떻게 되냐면 베이컨스를 보고 얘가 들어가고 CS를 하고 바꾸고 요 하는 그 전환 과정에서 이런 거예요.
ef 만약 마이턴이면

1:11:14
들어가요. 그래서 여기 들어가서 제일 먼저 뭐 하냐면 마이턴이니까 들어갔으니까 마이턴은 이제 폴스로 바꿔야 되겠죠.
남이 못 들어오게 나는 더 이상 못하게 그렇게 해놓고 내 차례는 아니야 이제 해놓고 이렇게 뭐 이렇게 수행을 CS를 수행한다든지 이렇게 되는 거예요.
근데 아니면 뭐 CS를 수행한 다음에 이거를 바꾼다든지 이렇게 하고 나온다든지 뭐 이런 코드를 쓰는데 이거는 어셈블링 레벨 랭귀즈에서 보면 컴페어라는 명령어로 합니다.
컴페어 레지스터 값하고 이게 이제 비교할 값하고 트루 포스가 이게 맞냐 이 레지스터 값을 가지고 컴페어를 하고 이거에 대해서 이제 필요하면 점프를 해서 뛰거나 뭐 이런 조건을 하는 거예요.
이게 이프은 이런 게 다 이렇게 바뀝니다. 근데 이다음에 내가 얘를 수행해야 되는데 이 명령을 수행하기 전에 요까지만 수행하고 이 단계에서 테스크 스위칭이 일어나버려 테스크 스위칭이 일어나서

1:12:14
딴 애한테 넘어갑니다. 그럼 딴 애는 아직까지 마이턴이 폴스가 되지 않은 상태에서 또 걔가 마이턴을 보고 또 들어온다든지 이런 문제가 생길 수가 있어요.
그래서 물론 이제 사실 좀 예제가 약간 애매하다. 이게 하여튼 아까 아가 2루냐 아니면 j가 2루냐 이걸 갖다가 서로 바꿔가면서 열었다 닫았다 열었다 닫았다 하는 조건에서 베이컨씨를 보고 들어갔는데 들어가가지고 이제 워큐파이로 바꿔야지라고 하는 상황에서 이거 들어간 상태에서 이때 갑자기 테스크 스위칭이 일어나요.
그러니까 어큐파이드로 못 바꿔놓은 상태예요. 그럼 다른 애가 딱 와가지고 베이컨스네 그러고 들어가는 거예요.
그러면 이제 문제가 되겠죠. 그런 식의 문제들이 있을 수 있다는 거예요.
그래서 사실 그렇게 해가지고 좀 이슈는 있습니다.
근데 어쨌든 블린 베어리브를 이용해서 인디케이 라이스 어베일러블 n한다는 거예요.
콜스 어콰이어 내가 만약에

1:13:12
락을 어콰이어 했으면은 또는 락을 릴리즈 했으면은 이렇게 해야 된다는데 머스트비 아토믹이 돼야 된다는 거예요.
아토믹 여기서 테스크 수칙이 일어나면 문제가 된다는 거예요.
그렇죠 그래서 적어도 베이컨시를 보고 들어가서 어큐파이드로 바꾸는 이 단계까지는 그렇죠 이 단계까지는 이게 한 단계가 아니라 두 단계 이상의 명령어 인스트럭션이 있더라도 아토믹으로 하드웨어적으로 보장하게끔 만들어야 된다는 게 유텍스의 방법입니다.
그렇게 하면 문제가 돼요. 그거 함수 하나 호출해주면 하드웨어적으로 처리되니까 안전한 거예요.
그래서 유지리 인플멘티드 비어 하드웨어 어터믹 인스트럭션을 통해서 한다.
여러분 mmx라고 옛날에 mmx 요새는 이제 이름이 ms SSE 이런 거가 있는데 이제 뭐냐 하면 멀티미디어 인스트럭션 셋이라고 그래서 멀티미디어 인스트럭션 셋 그래서 하드웨어에서 제공하는 멀티미디어용 명령어입니다.
이거를 만약에 인텔

1:14:29
CPU에서 제공한다 그러면 그거랑 관련된 헤더나 이런 걸 불러주고 라이브러리를 불러주고 내가 일반 c언어에 있는 함수가 아니지만 인텔에서 명령어에서 제공하는 특정한 명령어 함수를 불러줍니다.
그럼 얘는 결국은 컴파일러 어셈블리에 의해서 나중에 결과적으로 하드웨어적인 하드웨어적인 인스트럭션이 불립니다.
그래서 메모리가 예를 들면 8바이트씩 8비트씩 이렇게 이어져서 8,888이면 이게 하나의 4바이트짜리라서 인티저가 돼서 이게 캐리 오버가 이렇게 중간중간에 일어나야 되는데 8비트 단위로 우리가 데이터를 더하고 빼고 곱하고 나눈 거 이렇게 할 때는 레지스터 두 개를 불러놓고 멀티플리 애드하고 멀티플리 빼는 디바이드를 하거나 멀티플렉스를 하거나 멀티플렉스 저기 곱하기를 하거나 어쨌든 그런 저기 그런 명령들을 수행하게끔 기존에 기존에는 여러 단계의 인스트럭션을 썼어야 되는 그런 레벨의 새로운 명령어들을

1:15:55
인텔이나 이런 애들 또는 amg 이런 애들이 자기 자체적으로 하드웨어적 명령어를 추가할 수 있습니다.
그리고 이런 게 되게 좋으면은 사람들은 인터넷 CPU 사서 쓰면 이런 SSE 기법 쓰면은 영상 처리하거나 비디오 처리할 때 속도가 빨라져 그리고 그거 쓰는 거니까 좋아하는 거예요.
마찬가지로 이런 하드웨어를 제공하는 이런 하드웨어를 제공하는 명령어가 있으면 그거를 써서 인프리멘트 하면 된다 이거예요.
어콰이어 릴리즈도 소프트웨어적으로는 해결이 안 된다는 거예요.
그걸 통해서 하면 되고요. 그런데 이제 한 가지 문제가 디스 솔루션 리콰이어스 비지 웨이링 비지 웨이링은 계속 기다리는 거야.
아까 여기서 와일 없나요? 와일 무슨 조건이 만족하지 않으면 어떻게 되죠? 이 상황이 만약 이 조건이 1 1이면은 엔드니까 세미콜론이 있잖아요.
그럼 계속 돌고 있는 거죠. 이 조건이 맞냐 맞냐 맞냐 맞냐 맞냐 맞냐 맞냐 계속 돌고 있고

1:16:56
컴퓨터적으로는 아무 생산적이지 않은 그러니까 크리티컬 섹션에 들어가서 뭔가 중요한 일을 처리하거나 하는 생산적이지 않는 그냥 계속 체크만 하는 거예요.
이 말은 내가 화장실 문 앞에서 진득히 기다리고 앞에 사람이 나오면 들어가야지 하고 이걸 기다리는 게 아니라 요 앞에 가서 이게 이제 어큐파이드로 돼 있지만 베이컨시로 바뀌었나 바뀌었나 바뀌었나 계속 보는 거랑 똑같아요.
만약 이런 게 아니라 안에 있는 사람한테 녹화하는 시스템이면 노크해서 넉넉 누구 있어요? 저 있어요? 넉넉 누구 있어요? 계속 이거 하는 거랑 똑같아요.
왜냐하면 언제 나오면 자기가 막 들어가려고 그러니까 비지 웨이링이 되는 거죠.
그리고 이런 걸 우리가 스핀락이라고 합니다. 스핀락은 계속 돌면서 스핀이 도는 거죠.
돌면서 계속 락을 체크하는 건데 SPL은 불필요한 CPU 사이클을 낭비함으로 좋지 못한 구현이다 이겁니다.
그래서 아까처럼 와일문 돌면서 계속 제거 하는 거는 좋지 못한 시스템입니다.

1:17:59
그래서 이게 좀 예제가 나오고 이제 스텝마포가 이렇게 나오고 있는데 일단 이것까지 좀 말씀을 드릴게요.
어화이올 와일 만약 어베일러블하지가 않을 경우에는 비즈 웨이트 이거 세미콜론이죠.
그러니까 비즈 웨이트를 하고요. 어베일러블은 폴스 이걸 바꿔놓니다.
이제 나는 이 단계를 넘어왔어요. 그러니까 어베일러블하다 그러면 어베일러블하지 않다라고 이제 바꿔놓고 어콰이어를 하는 겁니다.
네 릴리즈는 어베일러블은 트루 니까 넌 이제 들어와도 돼 이걸로 하는 겁니다.
내가 화장실 들어갈 때랑 나올 때 쓸 수 있는 명령어 같은 거죠.
남이 써도 돼라고 푯말을 바꿔놓는 거고요. 만약 어베일러블하지 않으면 계속 기다리다가 어느 순간 이제 어베일러블 해지면 어베일러블은 너는 못 들어와 그러고 일단 아까 말한 대로 어큐파이드라고 바꾸는 그 개념에 해당합니다.
그래서 두 와일이 있는데 어콰이어 락을 하고요. 어콰이어

1:19:02
릴리즈 락을 해주는 거를 CS 들어갈 때와 나올 때 이걸 해준다 이겁니다.
근데 아까 말한 대로 여기 스핀락이 도는 게 있죠. 와일 이거를 이게 계속 스핀닥을 돌고 있으니 대기하는 애들은 CPU를 계속 잡아먹는 거죠.
단점이 좀 있습니다. 그래서 이런 부분들을 우리가 이제까지 조금 공부를 해봤고요.
다음 시간에 우리 세마포어부터 또 조금 더 설명을 하고 그다음에 우리 그래프 디어리 이런 거 좀 공부하도록 하겠습니다.
수고 많으셨습니다. 여러분.


clovanote.naver.com